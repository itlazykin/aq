## ImmutableClass

[1. Что такое immutable класс в Java?](#1-что-такое-immutable-класс-в-java)

[2. Какие преимущества предоставляют неизменяемые классы в Java?](#2-какие-преимущества-предоставляют-неизменяемые-классы-в-java)

[3. Какие основные правила необходимо соблюдать при создании immutable класса в Java?](#3-какие-основные-правила-необходимо-соблюдать-при-создании-immutable-класса-в-java)

[4. Как можно создать immutable класс, если в нем есть ссылочные поля, которые сами по себе могут быть изменяемыми?](#4-как-можно-создать-immutable-класс-если-в-нем-есть-ссылочные-поля-которые-сами-по-себе-могут-быть-изменяемыми)

[5. Какова роль ключевого слова final в создании immutable классов в Java?](#5-какова-роль-ключевого-слова-final-в-создании-immutable-классов-в-java)

[6. Почему важно предоставлять только методы для чтения (getter methods), не предоставляя методов для изменения состояния (setter methods), в immutable классах?](#6-почему-важно-предоставлять-только-методы-для-чтения-getter-methods-не-предоставляя-методов-для-изменения-состояния-setter-methods-в-immutable-классах)

[7. Как реализовать immutable класс с использованием паттерна Builder в Java?](#7-как-реализовать-immutable-класс-с-использованием-паттерна-builder-в-java)

[8. Можно ли сделать класс immutable, если он содержит массивы, и как это можно сделать?](#8-можно-ли-сделать-класс-immutable-если-он-содержит-массивы-и-как-это-можно-сделать)

[9. Как обеспечить идемпотентность методов в immutable классах и почему это важно?](#9-как-обеспечить-идемпотентность-методов-в-immutable-классах-и-почему-это-важно)


# 1. Что такое immutable класс в Java?

Иммутабельный класс - класс, экземпляры которого не могут быть изменены после создания.

[К оглавлению](#ImmutableClass)

# 2. Какие преимущества предоставляют неизменяемые классы в Java?

- Безопасность в многопоточной среде. Неизменяемые объекты по умолчанию потокобезопасны, так как их состояние нельзя изменить после создания. Нет необходимости в synchronization, что улучшает производительность.
- Нет "скрытых" изменений состояния
- Легче отлаживать и тестировать, поскольку объект всегда находится в предсказуемом состоянии.
- Неизменяемые объекты можно безопасно использовать как ключи в HashMap или HashSet, потому что их hashCode() не меняется
- Можно кэшировать и переиспользовать объекты (как String в пуле строк). (Integer.valueOf() использует кэш для значений от -128 до 127.)
- Не нужно делать глубокие копии (deep copy), так как объект не может быть изменён.

[К оглавлению](#ImmutableClass)

# 3. Какие основные правила необходимо соблюдать при создании immutable класса в Java?

- Сделать класс и все его поля final. 
- Не предоставлять сеттеров (setter methods).
- Если класс содержит изменяемые объекты (например, List), возвращать их копии в геттерах. 
- Инициализировать все поля через конструктор.

[К оглавлению](#ImmutableClass)

# 4. Как можно создать immutable класс, если в нем есть ссылочные поля, которые сами по себе могут быть изменяемыми?

`Защитное копирование`

- При сохранении объекта (в конструкторе или сеттере) → создаём глубокую копию (deep copy). При возврате объекта (в геттере) → также возвращаем копию.

`Использование неизменяемых коллекций`

- Если используется Java 9+, можно возвращать неизменяемые коллекции (List.copyOf, Collections.unmodifiableList).

```java
public List<String> getEmails() {
    return List.copyOf(emails); // Возвращает unmodifiableList
}
```

`Если поле — массив`

- В конструкторе копируем массив через Arrays.copyOf(). В геттере возвращаем копию или обёртку (Collections.unmodifiableList).

[К оглавлению](#ImmutableClass)

# 5. Какова роль ключевого слова final в создании immutable классов в Java?

- final для полей → запрещает изменение ссылки. 
- final для класса → запрещает наследование. 
- final не делает объект неизменяемым, если поле ссылается на изменяемый объект (например, List, массив или кастомный класс). 

`Для полной иммутабельности необходимо`:

- Использовать защитное копирование (в конструкторе и геттерах). 
- Возвращать неизменяемые представления (например, Collections.unmodifiableList). 
- Для массивов — использовать Arrays.copyOf().

[К оглавлению](#ImmutableClass)

# 6. Почему важно предоставлять только методы для чтения (getter methods), не предоставляя методов для изменения состояния (setter methods), в immutable классах?

- Запрещают изменение состояния → сохраняют иммутабельность. 
- Делают объект потокобезопасным без дополнительных блокировок. 
- Защищают от случайных изменений внешним кодом. 
- Позволяют безопасно использовать объект как ключ в HashMap.
- Дают возможность кэширования и оптимизаций.

[К оглавлению](#ImmutableClass)

# 7. Как реализовать immutable класс с использованием паттерна Builder в Java?

Без Lombok → больше контроля, но больше кода.

С Lombok → лаконично, но меньше гибкости в кастомизации.

- Поля класса — final (неизменяемые после инициализации). 
- Конструктор — приватный (вызывается только Builder'ом). 
- Только геттеры (никаких сеттеров!).
- Защитное копирование для изменяемых полей (List, Map, кастомные объекты). 
- Builder может быть mutable, но после build() объект становится immutable.

[К оглавлению](#ImmutableClass)

# 8. Можно ли сделать класс immutable, если он содержит массивы, и как это можно сделать?

Да. В конструкторе копируем массив через Arrays.copyOf(). В геттере возвращаем копию или обёртку (Collections.unmodifiableList).

[К оглавлению](#ImmutableClass)

# 9. Как обеспечить идемпотентность методов в immutable классах и почему это важно?

Идемпотентность означает, что повторный вызов метода с одними и теми же аргументами не изменяет результат после первого вызова.
В immutable-классах все методы по умолчанию идемпотентны, потому что состояние объекта нельзя изменить.

- Правило 1: Методы только возвращают данные (не изменяют состояние)
- Правило 2: Методы с вычислениями должны зависеть только от входных аргументов
- Правило 3: Для изменяемых полей — возвращаем копии или неизменяемые представления

[К оглавлению](#ImmutableClass)