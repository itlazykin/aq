## Jvm

[1. Что такое JVM?](#1-что-такое-jvm)

[2. В чем разница между JDK и JRE?](#2-в-чем-разница-между-jdk-и-jre)

[3. Какие основные компоненты JVM вы знаете?](#3-какие-основные-компоненты-jvm-вы-знаете)

[4. Как JVM выполняет Java-программу?](#4-как-jvm-выполняет-java-программу)

[5. Какие задачи выполняет сборщик мусора в JVM?](#5-какие-задачи-выполняет-сборщик-мусора-в-jvm)

[6. Какие типы сборщиков мусора вы знаете в JVM?](#6-какие-типы-сборщиков-мусора-вы-знаете-в-jvm)

[7. Опишите процесс загрузки классов в JVM.](#7-опишите-процесс-загрузки-классов-в-jvm)

[8. Какие особенности HotSpot JVM вы можете назвать?](#8-какие-особенности-hotspot-jvm-вы-можете-назвать)

[9. Как JVM управляет памятью, включая стек и кучу?](#9-как-jvm-управляет-памятью-включая-стек-и-кучу)

[10. Какие три основных загрузчика классов существуют в JVM?](#10-какие-три-основных-загрузчика-классов-существуют-в-jvm)

[11. Что такое загрузчик классов в Java?](#11-что-такое-загрузчик-классов-в-java)

[12. Какой загрузчик классов используется по умолчанию для загрузки пользовательских классов?](#12-какой-загрузчик-классов-используется-по-умолчанию-для-загрузки-пользовательских-классов)

[13. Какие задачи выполняет системный (или прикладной) загрузчик классов?](#13-какие-задачи-выполняет-системный-или-прикладной-загрузчик-классов)

[14. Как можно написать собственный загрузчик классов и для чего это может потребоваться?](#14-как-можно-написать-собственный-загрузчик-классов-и-для-чего-это-может-потребоваться)

[15. Как работает делегирование загрузки классов в Java?](#15-как-работает-делегирование-загрузки-классов-в-java)

[16. Как решается проблема разрешения циклических зависимостей между классами при загрузке?](#)

[17. Какие методы класса ClassLoader используются для загрузки классов?](#)

[18. Как JVM обрабатывает случай, когда два разных загрузчика классов загрузили классы с одинаковыми именами?](#18-как-jvm-обрабатывает-случай-когда-два-разных-загрузчика-классов-загрузили-классы-с-одинаковыми-именами)

[19. Что такое загрузчик классов в Java?](#19-что-такое-загрузчик-классов-в-java)

[20. Какие виды загрузчиков классов существуют в JVM?](#20-какие-виды-загрузчиков-классов-существуют-в-jvm)

[21. Для чего нужен загрузчик классов в Java?](#21-для-чего-нужен-загрузчик-классов-в-java)

[22. Как работает механизм делегирования загрузки классов в Java?](#22-как-работает-механизм-делегирования-загрузки-классов-в-java)

[23. Можно ли создать собственный загрузчик классов в Java? Если да, то как?](#23-можно-ли-создать-собственный-загрузчик-классов-в-java-если-да-то-как)

[24. Какие особенности безопасности следует учитывать при создании собственного загрузчика классов?](#24-какие-особенности-безопасности-следует-учитывать-при-создании-собственного-загрузчика-классов)

[25. Опишите процесс загрузки класса в JVM и как он связан с моделью делегирования.](#25-опишите-процесс-загрузки-класса-в-jvm-и-как-он-связан-с-моделью-делегирования)

[26. Как загрузчик классов может влиять на пространство имен классов?](#26-как-загрузчик-классов-может-влиять-на-пространство-имен-классов)

[27. В чем преимущества создания собственного загрузчика классов для загрузки классов из нестандартных источников?](#27-в-чем-преимущества-создания-собственного-загрузчика-классов-для-загрузки-классов-из-нестандартных-источников)

[28. Что такое куча (Heap) в контексте JVM?](#28-что-такое-куча-heap-в-контексте-jvm)

[29. Какие типы памяти существуют в Java Virtual Machine (JVM)?](#29-какие-типы-памяти-существуют-в-java-virtual-machine-jvm)

[30. Опишите, что такое стек (Stack) в JVM и для чего он используется.](#30-опишите-что-такое-стек-stack-в-jvm-и-для-чего-он-используется)

[31. Как работает сборка мусора (Garbage Collection) в куче JVM?](#31-как-работает-сборка-мусора-garbage-collection-в-куче-jvm)

[32. Каково назначение памяти Metaspace в JVM?](#32-каково-назначение-памяти-metaspace-в-jvm)

[33. Объясните разницу между Young и Old (Tenured) поколениями в куче JVM.](#33-объясните-разницу-между-young-и-old-tenured-поколениями-в-куче-jvm)

[34. Какие стратегии сборки мусора (Garbage Collection) существуют в JVM и в чем их особенности?](#34-какие-стратегии-сборки-мусора-garbage-collection-существуют-в-jvm-и-в-чем-их-особенности)

[35. Что такое Direct Memory в контексте JVM и как его использование влияет на производительность приложения?](#35-что-такое-direct-memory-в-контексте-jvm-и-как-его-использование-влияет-на-производительность-приложения)

[36. Как JVM обрабатывает intern-строки в памяти и как это влияет на производительность приложения?](#36-как-jvm-обрабатывает-intern-строки-в-памяти-и-как-это-влияет-на-производительность-приложения)

[37. Что такое JIT компиляция в контексте JVM?](#37-что-такое-jit-компиляция-в-контексте-jvm)

[38. Как JIT компиляция улучшает производительность Java программы?](#38-как-jit-компиляция-улучшает-производительность-java-программы)

[39. В чем разница между JIT компиляцией и AOT (Ahead-of-Time) компиляцией?](#39-в-чем-разница-между-jit-компиляцией-и-aot-ahead-of-time-компиляцией)

[40. Какие основные типы оптимизаций использует JIT компилятор?](#40-какие-основные-типы-оптимизаций-использует-jit-компилятор)

[41. В каких случаях JVM решает использовать JIT компиляцию для конкретного метода?](#41-в-каких-случаях-jvm-решает-использовать-jit-компиляцию-для-конкретного-метода)

[42. Как работают профилирование и инлайнинг в контексте JIT компиляции?](#42-как-работают-профилирование-и-инлайнинг-в-контексте-jit-компиляции)

[43. Опишите процесс деоптимизации в JIT и в каких случаях он применяется.](#43-опишите-процесс-деоптимизации-в-jit-и-в-каких-случаях-он-применяется)

[44. Какие существуют реализации JIT компилятора в различных JVM (например, HotSpot, GraalVM)?](#44-какие-существуют-реализации-jit-компилятора-в-различных-jvm-например-hotspot-graalvm)

[45. Как JIT компилятор взаимодействует с Garbage Collector'ом в JVM?](#45-как-jit-компилятор-взаимодействует-с-garbage-collectorом-в-jvm)

[46. Что такое сборщик мусора в Java?](#46-что-такое-сборщик-мусора-в-java)

[47. Какие основные типы сборщиков мусора вы знаете?](#47-какие-основные-типы-сборщиков-мусора-вы-знаете)

[48. Как работает механизм автоматической сборки мусора в JVM?](#48-как-работает-механизм-автоматической-сборки-мусора-в-jvm)

[49. Чем отличается сборка мусора Mark-Sweep от Copying?](#49-чем-отличается-сборка-мусора-mark-sweep-от-copying)

[50. Какие преимущества и недостатки у G1 Garbage Collector по сравнению с CMS?](#50-какие-преимущества-и-недостатки-у-g1-garbage-collector-по-сравнению-с-cms)

[51. Как работает сборщик мусора ZGC и для каких задач он наиболее подходит? ](#51-как-работает-сборщик-мусора-zgc-и-для-каких-задач-он-наиболее-подходит)

[52. Какие оптимизации используются сборщиками мусора для уменьшения пауз при сборке?](#52-какие-оптимизации-используются-сборщиками-мусора-для-уменьшения-пауз-при-сборке)

[53. Какие нововведения были реализованы в сборщике мусора Shenandoah по сравнению с другими сборщиками?](#53-какие-нововведения-были-реализованы-в-сборщике-мусора-shenandoah-по-сравнению-с-другими-сборщиками)

[54. Как JVM определяет, что объект является 'мусором' и его можно удалить?](#54-как-jvm-определяет-что-объект-является-мусором-и-его-можно-удалить)

[55. Что такое Java Memory Model (JMM)?](#55-что-такое-java-memory-model-jmm)

[56. Для чего используется ключевое слово volatile в Java?](#56-для-чего-используется-ключевое-слово-volatile-в-java)

[57. Что означает “visibility” (видимость) в контексте JMM?](#57-что-означает-visibility-видимость-в-контексте-jmm)

[58. Каким образом ключевое слово synchronized влияет на видимость и порядок выполнения?](#58-каким-образом-ключевое-слово-synchronized-влияет-на-видимость-и-порядок-выполнения)

[59. В чем разница между synchronized и volatile?](#59-в-чем-разница-между-synchronized-и-volatile)

[60. Какую роль играют happens-before отношения в JMM? Приведите пример.](#60-какую-роль-играют-happens-before-отношения-в-jmm-приведите-пример)

[61. Какие гарантии предоставляет JMM при использовании атомарных классов из пакета java.util.concurrent?](#61-какие-гарантии-предоставляет-jmm-при-использовании-атомарных-классов-из-пакета-javautilconcurrent)

[62. Что такое “reordering” и как оно влияет на многопоточность в Java?](#62-что-такое-reordering-и-как-оно-влияет-на-многопоточность-в-java)

[63. Как работает final в контексте JMM, и как это влияет на безопасную публикацию объектов?](#63-как-работает-final-в-контексте-jmm-и-как-это-влияет-на-безопасную-публикацию-объектов)

[64. Какие существуют способы публикации объекта между потоками? Примеры.](#64-какие-существуют-способы-публикации-объекта-между-потоками-примеры)

[65. Объясните влияние JMM на сборщик мусора (Garbage Collector) и его взаимодействие с потоками.](#65-объясните-влияние-jmm-на-сборщик-мусора-garbage-collector-и-его-взаимодействие-с-потоками)

[66. Как можно добиться безопасного завершения потоков в Java с учетом JMM?](#66-как-можно-добиться-безопасного-завершения-потоков-в-java-с-учетом-jmm)

[67. Какие проблемы могут возникнуть при неправильно настроенном lazy initialization в многопоточности? Как их решить?](#67-какие-проблемы-могут-возникнуть-при-неправильно-настроенном-lazy-initialization-в-многопоточности-как-их-решить)

[68. Объясните семантику happens-before в контексте чтения и записи с использованием Lock и Condition.](#68-объясните-семантику-happens-before-в-контексте-чтения-и-записи-с-использованием-lock-и-condition)

# 1. Что такое JVM?

JVM — это виртуальная машина, которая исполняет байткод Java, независимо от ОС и железа. Она включает в себя систему
управления памятью, JIT-компилятор, GC и multithreading-механизмы. Благодаря JVM Java остаётся кроссплатформенной. Плюс,
я довольно хорошо понимаю устройство JVM: heap, stack, metaspace, работа JIT-компилятора и особенности GC, такие, как G1
и ZGC — всё это напрямую влияет на производительность, и я умею с этим работать.

[К оглавлению](#Jvm)

# 2. В чем разница между JDK и JRE?

JRE — это среда выполнения включает JVM и стандартные библиотеки, но без компилятора и инструментов разработки. А
JDK — это полноценный комплект для разработки, в него уже входит JRE, плюс компилятор javac и утилиты вроде jconsole,
jstack, jmap. С Java 11 Oracle даже перестала выпускать отдельный JRE, и теперь используется JDK как основной runtime. В
реальной практике я, конечно, всегда работаю с JDK — от сборки до отладки и анализа производительности

[К оглавлению](#Jvm)

# 3. Какие основные компоненты JVM вы знаете?

- Class Loader — загружает классы в память, работает по делегирующей модели.
- Runtime Data Areas — heap, stack, metaspace и прочее, где управляется память.
- Execution Engine — интерпретатор, JIT-компилятор и GC.
- JNI — для вызова нативного кода.

[К оглавлению](#Jvm)

# 4. Как JVM выполняет Java-программу?

Когда я запускаю Java-программу, сначала исходный код компилируется в байткод. Затем JVM запускается, загружает основной
класс через цепочку загрузчиков, выполняет верификацию, связывает классы и выделяет память. Далее, Execution Engine
интерпретирует или компилирует байткод в нативный код с помощью JIT. Параллельно работает GC, который управляет очисткой
памяти.

[К оглавлению](#Jvm)

# 5. Какие задачи выполняет сборщик мусора в JVM?

Сборщик мусора в JVM отвечает за автоматическое управление памятью: он находит объекты, на которые больше нет ссылок, и
освобождает занимаемую ими память. Современные GC стараются минимизировать stop-the-world паузы и управляют памятью по
поколениям — Young и Old.

[К оглавлению](#Jvm)

# 6. Какие типы сборщиков мусора вы знаете в JVM?

Serial GC — для простых, однопоточных приложений.

Parallel GC — когда нужен максимальный throughput, например, в batch-процессах.

G1 GC — мой основной выбор в продакшене, он даёт баланс между паузами и производительностью.

Также работал с ZGC, когда требовались минимальные паузы при большом объёме heap — это критично для real-time аналитики.
Понимание GC помогает мне анализировать GC-логи, правильно настраивать параметры JVM и избегать проблем с переполнением
памяти или задержками.

[К оглавлению](#Jvm)

# 7. Опишите процесс загрузки классов в JVM.

ClassLoader пытается найти класс в classpath, используя стандартных или кастомных загрузчиков.

Класс проверяется на корректность байткода и безопасность.

Далее происходит связывание: подготовка памяти для статических переменных, разрешение ссылок и инициализация статических
блоков.

После этого класс готов к использованию JVM.

[К оглавлению](#Jvm)

# 8. Какие особенности HotSpot JVM вы можете назвать?

HotSpot — это реализация JVM, которая активно используется в большинстве Java-платформ. Её основное отличие — это
Just-In-Time компиляция, при которой часто вызываемые методы компилируются в нативный код во время исполнения, с
использованием профилирования. HotSpot поддерживает мощные оптимизации: inlining, escape analysis, dead code elimination
и другие.

[К оглавлению](#Jvm)

# 9. Как JVM управляет памятью, включая стек и кучу?

JVM управляет памятью через две основные области: Heap и Stack. Stack используется для хранения локальных переменных,
примитивов и контекста вызовов — он создаётся на каждый поток. Heap используется для всех объектов, он делится на Young
и Old Generation и управляется GC. C Java 8 информация о классах хранится в Metaspace, а не в PermGen.

[К оглавлению](#Jvm)

# 10. Какие три основных загрузчика классов существуют в JVM?

Bootstrap ClassLoader — загружает базовые классы JDK на нативном уровне,

Extension (или Platform) ClassLoader — загружает расширения и дополнительные библиотеки,

System (Application) ClassLoader — загружает классы из classpath приложения. Они работают по модели делегирования, где
каждый загрузчик сначала делегирует запрос родителю, что обеспечивает безопасность и стабильность загрузки классов.

[К оглавлению](#Jvm)

# 11. Что такое загрузчик классов в Java?

Загрузчик классов в Java — это компонент JVM, который отвечает за поиск и загрузку байт-кода классов в память по мере
необходимости. Он обеспечивает динамическую загрузку классов, позволяет управлять изоляцией и видимостью классов через
иерархию загрузчиков и делегирование. Кроме того, можно создавать кастомные загрузчики для специальных случаев,
например, динамической загрузки плагинов

[К оглавлению](#Jvm)

# 12. Какой загрузчик классов используется по умолчанию для загрузки пользовательских классов?

По умолчанию JVM для загрузки классов приложения использует System ClassLoader, который загружает классы из classpath.
Он работает по делегирующей модели, сначала пытаясь загрузить класс через Bootstrap и Extension загрузчики. System
ClassLoader — это загрузчик, который обычно используют для загрузки пользовательских классов и библиотек в приложении.

[К оглавлению](#Jvm)

# 13. Какие задачи выполняет системный (или прикладной) загрузчик классов?

Системный или прикладной загрузчик классов отвечает за загрузку всех классов и библиотек, которые находятся в classpath
приложения. Он работает по делегирующей модели, сначала пытаясь загрузить класс через родительские загрузчики (Bootstrap
и Extension), а если класс не найден — загружает сам. Кроме того, он управляет областью видимости классов приложения,
поддерживает динамическую загрузку классов через Reflection и обеспечивает безопасность при загрузке

[К оглавлению](#Jvm)

# 14. Как можно написать собственный загрузчик классов и для чего это может потребоваться?

Собственный загрузчик классов создаётся путём наследования от ClassLoader и переопределения метода findClass, в котором
реализуется логика загрузки байт-кода класса из нестандартного источника. Это может быть файл, сеть или база данных.
Обычно загрузчик следует делегирующей модели, чтобы сначала обратиться к родительским загрузчикам. Основные применения —
динамическая загрузка плагинов, изоляция разных версий библиотек, безопасность, а также трансформация байт-кода и
загрузка из нестандартных мест

[К оглавлению](#Jvm)

# 15. Как работает делегирование загрузки классов в Java?

В Java загрузчики классов работают по модели делегирования: когда загрузчик получает запрос загрузить класс, он сначала
делегирует этот запрос родительскому загрузчику. Если родитель не находит класс, загрузчик пытается загрузить класс
самостоятельно. Это обеспечивает безопасность и консистентность классов, предотвращает подмену системных классов и
позволяет повторно использовать уже загруженные классы

[К оглавлению](#Jvm)

# 16. Как решается проблема разрешения циклических зависимостей между классами при загрузке?

JVM решает проблему циклических зависимостей классов через поэтапный процесс загрузки: сначала классы загружаются и
связываются, создавая заглушки для классов и их полей, без инициализации. Это позволяет рекурсивно загружать
взаимозависимые классы без проблем. Инициализация статических блоков происходит после загрузки, и она выполняется
последовательно для каждого класса, что помогает избежать бесконечных циклов загрузки. Однако в коде стоит избегать
сложных взаимных статических инициализаций, чтобы не столкнуться с непредсказуемым поведением

[К оглавлению](#Jvm)

# 17. Какие методы класса ClassLoader используются для загрузки классов?

Основной метод загрузки класса в ClassLoader — это публичный loadClass(String name), который работает по делегирующей
модели: сначала пытается загрузить класс через родительский загрузчик, а при неудаче вызывает защищённый метод
findClass(String name), который нужно переопределять в собственных загрузчиках, чтобы реализовать логику поиска
байт-кода. Для регистрации загруженного байт-кода используется метод defineClass, а метод resolveClass связывает класс.
Таким образом, loadClass управляет всей цепочкой загрузки и связывания класса в JVM

[К оглавлению](#Jvm)

# 18. Как JVM обрабатывает случай, когда два разных загрузчика классов загрузили классы с одинаковыми именами?

В JVM класс идентифицируется не только своим полным именем, но и загрузчиком классов, который его загрузил. Поэтому если
два разных загрузчика загрузили классы с одинаковым именем, JVM считает эти классы разными, и они не совместимы друг с
другом. Это ключевая особенность, которая позволяет реализовывать изоляцию классов и загружать разные версии библиотек в
одном приложении. Однако при этом нужно быть осторожным, чтобы не возникало ClassCastException при взаимодействии таких
классов

[К оглавлению](#Jvm)

# 19. Что такое загрузчик классов в Java?

Загрузчик классов в Java — это компонент JVM, который отвечает за поиск и загрузку байт-кода классов в память по мере
необходимости. Он обеспечивает динамическую загрузку классов, позволяет управлять изоляцией и видимостью классов через
иерархию загрузчиков и делегирование. Кроме того, можно создавать кастомные загрузчики для специальных случаев,
например, динамической загрузки плагинов

[К оглавлению](#Jvm)

# 20. Какие виды загрузчиков классов существуют в JVM?

Bootstrap ClassLoader — загружает классы стандартной библиотеки Java (например, java.lang.*), он является частью самой
JVM и не может быть изменён.

Extension ClassLoader — загружает классы из расширений JVM, таких как библиотеки в каталоге lib/ext.

System ClassLoader — загружает классы из classpath приложения и используется для загрузки классов, определённых
пользователем или сторонними библиотеками

[К оглавлению](#Jvm)

# 21. Для чего нужен загрузчик классов в Java?

Загрузчик классов в Java нужен для динамической загрузки классов в память во время выполнения программы, а не только при
запуске. Он обеспечивает изоляцию и модульность, позволяя загружать разные версии библиотек в одном приложении. Также
загрузчик играет ключевую роль в безопасности JVM, предотвращая подмену системных классов, и реализует делегирующую
модель загрузки, что упорядочивает процесс и предотвращает дублирование классов. Это даёт гибкость и расширяемость
приложения

[К оглавлению](#Jvm)

# 22. Как работает механизм делегирования загрузки классов в Java?

В Java загрузчики классов работают по модели делегирования: когда загрузчик получает запрос загрузить класс, он сначала
делегирует этот запрос родительскому загрузчику. Если родитель не находит класс, загрузчик пытается загрузить класс
самостоятельно. Это обеспечивает безопасность и консистентность классов, предотвращает подмену системных классов и
позволяет повторно использовать уже загруженные классы

[К оглавлению](#Jvm)

# 23. Можно ли создать собственный загрузчик классов в Java? Если да, то как?

```java
public class MyClassLoader extends ClassLoader {

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] classBytes = loadClassBytes(name);
        if (classBytes == null) {
            throw new ClassNotFoundException(name);
        }
        return defineClass(name, classBytes, 0, classBytes.length);
    }

    private byte[] loadClassBytes(String className) {
        // Логика чтения байт-кода класса по имени
        // Например, из файла: "com/example/MyClass.class"
        // Вернуть массив байт или null если не найден
    }
}
```

Да, собственный загрузчик классов в Java можно создать, наследуясь от ClassLoader и переопределяя метод findClass, в
котором реализуется логика поиска и чтения байт-кода класса. В этом методе вызывается defineClass, который превращает
массив байт в объект класса JVM. При этом обычно сохраняется делегирующая модель загрузки, вызывая родительский
загрузчик через loadClass. Такой подход используется для динамической загрузки плагинов, модулей и других расширений

[К оглавлению](#Jvm)

# 24. Какие особенности безопасности следует учитывать при создании собственного загрузчика классов?

При создании собственного загрузчика классов обязательно следует сохранять делегирующую модель, чтобы системные классы
загружались родительским загрузчиком и не могли быть подменены. Важно проверять и валидировать загружаемые классы,
особенно если они поступают из ненадёжных источников, ограничивать область видимости и доступ загруженного кода к
системным ресурсам, а также контролировать жизненный цикл загрузчика, чтобы избежать утечек памяти. Всё это обеспечивает
безопасность и стабильность приложения.

[К оглавлению](#Jvm)

# 25. Опишите процесс загрузки класса в JVM и как он связан с моделью делегирования.

Процесс загрузки класса в JVM состоит из трёх этапов: загрузка байт-кода в память, связывание (проверка, подготовка и
разрешение) и инициализация статических элементов класса. При загрузке JVM использует модель делегирования загрузчиков
классов: запрос на загрузку сначала делегируется родительскому загрузчику вплоть до Bootstrap ClassLoader. Если класс
найден родителем, он используется, иначе загрузчик пытается загрузить класс самостоятельно. Это обеспечивает
безопасность и консистентность загруженных классов

[К оглавлению](#Jvm)

# 26. Как загрузчик классов может влиять на пространство имен классов?

В JVM пространство имён классов определяется не только именем класса, но и загрузчиком классов, который его загрузил.
Два класса с одинаковым полным именем, загруженные разными загрузчиками, считаются разными и несовместимыми для JVM. Это
позволяет загружать разные версии одной библиотеки одновременно и обеспечивает изоляцию и безопасность между модулями
или плагинами

[К оглавлению](#Jvm)

# 27. В чем преимущества создания собственного загрузчика классов для загрузки классов из нестандартных источников?

Создание собственного загрузчика классов позволяет загружать классы из нестандартных источников — например, из сети,
базы данных или зашифрованных хранилищ — что расширяет гибкость приложения. Это даёт возможность динамически обновлять
классы без перезапуска, изолировать разные версии библиотек и повышать безопасность, добавляя валидацию или проверку.
Также такой загрузчик помогает управлять жизненным циклом классов и поддерживать сложные модульные архитектуры

[К оглавлению](#Jvm)

# 28. Что такое куча (Heap) в контексте JVM?

Куча в JVM — это область памяти, где создаются и хранятся все объекты и массивы во время выполнения программы. Куча
управляется сборщиком мусора, который автоматически освобождает память от неиспользуемых объектов. Куча общая для всех
потоков и её размер можно настраивать. Это ключевая часть управления памятью в JVM

[К оглавлению](#Jvm)

# 29. Какие типы памяти существуют в Java Virtual Machine (JVM)?

JVM имеет несколько типов памяти: кучу (heap) для объектов, стек (stack) для локальных переменных и вызовов методов — у
каждого потока свой стек, методную область (method area), где хранятся метаданные классов и статические данные,
PC-регистр с адресом текущей инструкции для каждого потока и стек для нативных методов. С Java 8 методная область
реализована как Metaspace и хранится вне кучи в нативной памяти

[К оглавлению](#Jvm)

# 30. Опишите, что такое стек (Stack) в JVM и для чего он используется.

Стек в JVM — это область памяти, выделенная для каждого потока отдельно, где хранятся фреймы вызовов методов. Каждый
фрейм содержит локальные переменные, параметры, операнды и информацию для возврата из метода. Стек управляет выполнением
методов и обеспечивает изоляцию потоков. Это быстрое и эффективное место хранения для данных, срок жизни которых
ограничен временем выполнения метода

[К оглавлению](#Jvm)

# 31. Как работает сборка мусора (Garbage Collection) в куче JVM?

В JVM управление памятью автоматическое, с помощью Garbage Collection. Куча делится на Young Generation (Eden + Survivor
0/1) и Old Generation. Новые объекты создаются в Eden, при его заполнении запускается Minor GC — выжившие объекты
перемещаются между Survivor-зонами, а после нескольких циклов попадают в Old. Если Old заполняется, происходит Major
GC (более медленный, иногда с паузами). Современные алгоритмы, такие как G1 или ZGC, минимизируют паузы. Объект
считается мусором, если он недостижим из GC Roots (например, нет ссылок из стека или статических полей).

Чтобы уменьшить влияние GC, можно настраивать размеры областей через флаги (-Xms, -Xmx), выбирать алгоритм под
нагрузку (например, G1 для больших heap’ов) и избегать утечек памяти — например, не хранить ссылки в статических
коллекциях

[К оглавлению](#Jvm)

# 32. Каково назначение памяти Metaspace в JVM?

Metaspace — это область памяти в JVM (вне кучи), которая хранит метаданные загруженных классов: структуры, методы,
константные пулы. В отличие от старого PermGen (который был частью кучи), Metaspace динамически расширяется в
native-памяти и не требует жёсткой настройки. Память освобождается, когда ClassLoader выгружается (например, при
redeploy приложения). Утечки могут возникать из-за динамической генерации классов (например, через CGLIB) или "
протекающих" ClassLoader’ов. Чтобы избежать проблем, можно ограничить Metaspace флагами `-XX:MaxMetaspaceSize` и
мониторить загрузку классов.

В высоконагруженных приложениях (например, сервисах с hot deploy) стоит следить за Metaspace, чтобы избежать
OutOfMemoryError. Также можно использовать `-XX:+CMSClassUnloadingEnabled` для выгрузки классов в сборщике CMS/G1.

[К оглавлению](#Jvm)

# 33. Объясните разницу между Young и Old (Tenured) поколениями в куче JVM.

В JVM куча разделена на Young и Old Generation для оптимизации сборки мусора. В Young Generation (Eden + Survivor 0/1)
создаются новые объекты, и здесь работает быстрый Minor GC, который удаляет короткоживущие объекты. Выжившие после
нескольких сборок объекты перемещаются в Old Generation, где сборка (Major GC) происходит реже, но с более долгими
паузами. Разделение позволяет уменьшить накладные расходы GC, так как большинство объектов умирают молодыми (weak
generational hypothesis). Для настройки можно использовать флаги вроде `-Xmn` (размер Young)
и `-XX:MaxTenuringThreshold` (
возраст перехода в Old)

[К оглавлению](#Jvm)

# 34. Какие стратегии сборки мусора (Garbage Collection) существуют в JVM и в чем их особенности?

- Serial GC — однопоточный, для простых приложений. Алгоритм:

    - Маркировка-очистка-уплотнение (Mark-Sweep-Compact) для Old.
    - Копирование (Copying) для Young.

- Parallel GC — максимизирует пропускную способность, но с долгими паузами (дефолт в Java 8). Алгоритм:
    - Многопоточная версия Serial GC.
    - Копирование (Copying) в Young, Mark-Sweep-Compact в Old.

- CMS — уменьшает паузы, но deprecated. Алгоритм:
    - Concurrent фазы (минимизация пауз).
    - Маркировка-очистка (без уплотнения) → возможна фрагментация.

- G1 — баланс между задержками и пропускной способностью (дефолт с Java 9). Алгоритм:
    - Делит кучу на регионы (regions) (1–32 МБ).
    - Собирает наиболее заполненные регионы (отсюда "Garbage-First").

- ZGC/Shenandoah — субмиллисекундные паузы на больших кучах. Алгоритм:
    - Параллельный (паузы < 1 мс даже на больших кучах).
    - Использует указатели с цветными битами (colored pointers).

Выбор зависит от требований: например, для высоконагруженного бэкенда с большим heap’ом подойдёт ZGC, а для
batch-обработки — Parallel GC.

На практике важно мониторить GC-логи (-Xlog:gc*) и настраивать размеры областей (например, -Xmx для кучи, -XX:
MaxGCPauseMillis для G1). Для веб-приложений с SLA по задержкам лучше использовать G1 или ZGC.

[К оглавлению](#Jvm)

# 35. Что такое Direct Memory в контексте JVM и как его использование влияет на производительность приложения?

Direct Memory — это область вне кучи JVM, выделяемая через ByteBuffer.allocateDirect(). Она используется для ускорения
I/O (NIO, JNI) и работы с большими данными, так как позволяет избежать копирования между Heap и Native-памятью. Однако
требует ручного контроля: при неосторожном использовании возможны утечки (OutOfMemoryError: Direct buffer memory). Для
ограничения можно задать `-XX:MaxDirectMemorySize`, а мониторить через NMT или JMX

[К оглавлению](#Jvm)

# 36. Как JVM обрабатывает intern-строки в памяти и как это влияет на производительность приложения?

String Pool — это область в куче JVM, где хранятся уникальные строковые литералы. Метод intern() позволяет поместить
строку в пул для повторного использования, что экономит память и ускоряет сравнение через ==. Однако злоупотребление
интернированием (особенно динамических строк) может привести к росту кучи и утечкам. С Java 7 пул перемещён из PermGen в
Heap, что упрощает его управление сборщиком мусора. Для оптимизации стоит интернировать только часто используемые
константы, например, ключи в HashMap."

Вместо intern() можно использовать ConcurrentHashMap для ручного кэширования строк — это даёт больше контроля и избегает
блокировок.

[К оглавлению](#Jvm)

# 37. Что такое JIT компиляция в контексте JVM?

JIT-компиляция в JVM преобразует байт-код в нативный машинный код во время выполнения, что значительно ускоряет работу
программ после прогрева. JVM использует два компилятора: C1 (для быстрой компиляции) и C2 (для глубокой оптимизации).
Сбор статистики (профилирование) позволяет JIT применять инлайнинг, удаление мёртвого кода и другие оптимизации. Для
мониторинга можно использовать флаги вроде -XX:+PrintCompilation. В отличие от AOT (например, GraalVM Native Image), JIT
адаптируется под конкретную нагрузку, но требует времени на «прогрев»

[К оглавлению](#Jvm)

# 38. Как JIT компиляция улучшает производительность Java программы?

JIT-компиляция в JVM динамически преобразует часто выполняемый байт-код в оптимизированный нативный код, что резко
повышает производительность. Ключевые техники: инлайнинг методов, удаление мёртвого кода, размотка циклов и
специализация под конкретные условия. Многоуровневая компиляция (C1/C2) балансирует между скоростью и глубиной
оптимизаций. Однако максимум скорости достигается после «прогрева» — JIT требует времени для сбора статистики и
компиляции

[К оглавлению](#Jvm)

# 39. В чем разница между JIT компиляцией и AOT (Ahead-of-Time) компиляцией?

JIT компилирует код во время выполнения, анализируя «горячие» участки и применяя адаптивные оптимизации (инлайнинг,
удаление мёртвого кода). Это даёт высокую пиковую производительность, но требует времени на прогрев. AOT компилирует всё
заранее, обеспечивая мгновенный старт и работу без JVM, но без runtime-оптимизаций. В Java JIT используется по
умолчанию (HotSpot), а AOT — в GraalVM Native Image для микросервисов и CLI-утилит.

Выбор зависит от сценария:

- JIT — для долго работающих серверов с динамической нагрузкой.

- AOT — если важны быстрый старт и минимальное потребление памяти (например, в serverless или контейнерах).

[К оглавлению](#Jvm)

# 40. Какие основные типы оптимизаций использует JIT компилятор?

JIT-компилятор применяет множество оптимизаций во время выполнения: встраивание часто вызываемых методов (inlining),
escape analysis для размещения объектов в стеке, удаление мёртвого кода, разворачивание циклов, деоптимизацию
виртуальных вызовов и оптимизацию синхронизированных блоков. Он также использует данные профилирования, чтобы
динамически адаптировать и ускорять горячие участки кода

[К оглавлению](#Jvm)

# 41. В каких случаях JVM решает использовать JIT компиляцию для конкретного метода?

JVM применяет JIT-компиляцию к методам, которые становятся горячими — то есть часто вызываются или содержат часто
повторяющиеся циклы. Она делает это на основе статистики профилирования: считает вызовы метода, количество итераций
циклов, отслеживает часто берущиеся ветки и стабильные типы объектов. После достижения порога JVM передаёт метод
компилятору C1 или C2, чтобы превратить байт-код в высокооптимизированный машинный код

[К оглавлению](#Jvm)

# 42. Как работают профилирование и инлайнинг в контексте JIT компиляции?

Во время интерпретации JVM собирает статистику выполнения — как часто вызываются методы, какие типы объектов
используются, какие ветки условий чаще берутся. Это называется профилированием. Когда метод становится 'горячим',
JIT-компилятор использует эту информацию, чтобы, например, встроить вызываемые методы (инлайнинг), если они короткие и
вызываются с одинаковыми типами. Это не только избавляет от накладных расходов вызова, но и позволяет проводить более
глубокие оптимизации, такие как удаление мёртвого кода или escape-анализ

[К оглавлению](#Jvm)

# 43. Опишите процесс деоптимизации в JIT и в каких случаях он применяется.

Деоптимизация — это механизм, при котором JVM возвращается от JIT-компилированного кода обратно к интерпретируемому,
если нарушаются допущения, на которых основывались оптимизации. Это может произойти, например, при изменении типа
объекта в методе, который ранее был деvirtualизирован, при динамической загрузке новых классов или при нарушении
условий, использованных для инлайнинга. JVM сохраняет метаинформацию, чтобы восстановить контекст выполнения, и
переключается на интерпретатор, чтобы сохранить корректность исполнения

[К оглавлению](#Jvm)

# 44. Какие существуют реализации JIT компилятора в различных JVM (например, HotSpot, GraalVM)?

В стандартной HotSpot JVM есть два JIT-компилятора: C1 (быстрый, лёгкий) и C2 (агрессивно оптимизирующий). Они работают
по принципу tiered compilation. В GraalVM используется Graal JIT — компилятор нового поколения, написанный на Java, с
более модульной архитектурой и расширенными оптимизациями. Есть также OpenJ9 от Eclipse с собственным JIT,
оптимизированным для облаков. В зависимости от JVM можно получить разный баланс между производительностью, временем
запуска и потреблением памяти

[К оглавлению](#Jvm)

# 45. Как JIT компилятор взаимодействует с Garbage Collector'ом в JVM?

JIT и GC работают вместе в JVM. JIT вставляет специальные точки останова — safepoint'ы — в машинный код, чтобы GC мог
безопасно приостановить выполнение и собрать мусор. JIT также применяет escape analysis: если объект не утекает из
метода, он размещается в стеке — это снижает нагрузку на GC. Кроме того, JIT встраивает инструкции write barrier и read
barrier, которые нужны современным сборщикам мусора, таким как G1 или ZGC, для отслеживания изменений в памяти. Таким
образом, они работают как части единого оптимизирующего механизма

[К оглавлению](#Jvm)

# 46. Что такое сборщик мусора в Java?

Сборщик мусора в Java — это компонент JVM, который автоматически управляет памятью. Он отслеживает, какие объекты больше
не используются, и удаляет их из кучи, чтобы освободить ресурсы. Основной алгоритм основан на достижимости от GC Roots.
Существуют разные реализации GC, от простого Serial до продвинутых, таких как G1, ZGC и Shenandoah, каждая
оптимизирована под разные сценарии нагрузки и требования к задержкам. GC — важный механизм, позволяющий писать надёжный
код без утечек памяти

[К оглавлению](#Jvm)

# 47. Какие основные типы сборщиков мусора вы знаете?

Существует несколько сборщиков мусора в JVM. Serial GC — однопоточный и простой. Parallel GC использует многопоточность
и оптимален по пропускной способности. G1 GC — современный GC по умолчанию, делит heap на регионы и управляет паузами.
ZGC и Shenandoah — низкопаузные сборщики, в которых паузы не зависят от размера кучи. Я чаще всего использую G1, но знаю
флаги и особенности переключения между GC в зависимости от потребностей приложения

[К оглавлению](#Jvm)

# 48. Как работает механизм автоматической сборки мусора в JVM?

JVM использует сборщик мусора, чтобы автоматически управлять памятью. Он отслеживает достижимость объектов от корневых
ссылок (GC Roots). GC работает в несколько этапов: сначала помечает живые объекты, затем удаляет недостижимые, а иногда
уплотняет память. Память делится на поколения, и молодые объекты собираются отдельно от старых. В зависимости от типа
GC (Serial, G1, ZGC и др.), сборка может выполняться однопоточно, параллельно или конкурентно. GC — это одна из ключевых
причин, почему Java освобождает разработчика от ручного управления памятью

[К оглавлению](#Jvm)

# 49. Чем отличается сборка мусора Mark-Sweep от Copying?

Алгоритм Mark-Sweep сначала помечает живые объекты, а затем удаляет все недостижимые. Его недостаток — возможная
фрагментация памяти. В отличие от него, Copying GC копирует только живые объекты в новую область, благодаря чему
избегает фрагментации. Copying лучше работает на молодых поколениях, где большинство объектов умирает быстро, а
Mark-Sweep — на старших, где объектов больше и они живут дольше

[К оглавлению](#Jvm)

# 50. Какие преимущества и недостатки у G1 Garbage Collector по сравнению с CMS?

G1 GC — это современная замена CMS, ориентированная на предсказуемые паузы и работу с большими кучами. В отличие от CMS,
G1 делит память на регионы и способен выполнять компактацию параллельно, избегая фрагментации. Кроме того, G1 позволяет
управлять длиной пауз с помощью параметра MaxGCPauseMillis. Однако у него немного выше потребление памяти и CPU.
Несмотря на это, CMS считается устаревшим и удалён из Java 14, так что в современных системах G1 — предпочтительный
выбор

[К оглавлению](#Jvm)

# 51. Как работает сборщик мусора ZGC и для каких задач он наиболее подходит?

ZGC — это современный, низкопаузный сборщик мусора, разработанный для систем с большими кучами и строгими требованиями к
задержкам. Он выполняет почти все фазы сборки параллельно с работой приложения, включая mark, relocate и remap.
Благодаря использованию colored pointers и load barriers ZGC избегает длительных Stop-The-World пауз. Это делает его
идеальным выбором для real-time и high-load систем, особенно с кучами в сотни гигабайт или больше

[К оглавлению](#Jvm)

# 52. Какие оптимизации используются сборщиками мусора для уменьшения пауз при сборке?

JVM использует ряд оптимизаций для уменьшения пауз GC: во-первых, память разделяется на поколения, чтобы часто собирать
только молодые объекты. Во-вторых, современные GC, как G1, ZGC и Shenandoah, выполняют фазы mark и relocate параллельно
с работой приложения. Также используется компактация по регионам, предсказание длительности пауз, и продвинутая техника,
как colored pointers, которая позволяет безопасно перемещать объекты без полной остановки. Все эти техники позволяют
сократить паузы GC до миллисекунд даже при больших объёмах памяти

[К оглавлению](#Jvm)

# 53. Какие нововведения были реализованы в сборщике мусора Shenandoah по сравнению с другими сборщиками?

Shenandoah — это низкопаузный GC, который выделяется тем, что выполняет даже компактацию памяти параллельно с работой
приложения. Он использует load barriers для обновления ссылок во время исполнения и обеспечивает предсказуемые паузы в
пределах 10-20 мс, независимо от размера кучи. Shenandoah подходит для задержка-чувствительных и многопоточных
приложений, где стабильность и предсказуемость GC важнее всего.

[К оглавлению](#Jvm)

# 54. Как JVM определяет, что объект является 'мусором' и его можно удалить?

JVM определяет, что объект является мусором, с помощью алгоритма трассировки достижимости. Сначала строится граф ссылок,
начиная от GC Roots — это активные потоки, локальные переменные, статические поля и т.д. Объекты, на которые нельзя
добраться по этому графу, считаются мусором и подлежат сборке. JVM использует алгоритмы вроде Mark-Sweep или их
модификации в G1, ZGC и других, поскольку они корректно работают даже с циклическими ссылками.

[К оглавлению](#Jvm)

# 55. Что такое Java Memory Model (JMM)?

Java Memory Model — это формальная спецификация, которая описывает, как потоки взаимодействуют с общей памятью. Она
определяет правила видимости, порядок исполнения инструкций и гарантии happens-before. Без JMM поведение многопоточного
кода было бы непредсказуемым из-за оптимизаций на уровне компилятора и процессора. Ключевые механизмы JMM — это
synchronized, volatile и happens-before, которые позволяют писать корректные и безопасные многопоточные программы

[К оглавлению](#Jvm)

# 56. Для чего используется ключевое слово volatile в Java?

`volatile` используется в Java для обеспечения видимости изменений переменной между потоками. Она гарантирует, что
каждый доступ к переменной происходит напрямую из main memory и запрещает переупорядочивание инструкций. Это особенно
полезно для флагов и статусов, где не требуется атомарность. Однако volatile не обеспечивает эксклюзивный доступ и не
подходит для составных операций — для этого используют synchronized или атомарные классы из java.util.concurrent

[К оглавлению](#Jvm)

# 57. Что означает “visibility” (видимость) в контексте JMM?

Visibility в Java Memory Model означает, что изменения, сделанные одним потоком, становятся видны другим. Без
специальных механизмов, как volatile или synchronized, поток может видеть устаревшие значения переменных из-за
кэширования и переупорядочивания инструкций. JMM решает эту проблему через правила happens-before. Например, чтение
volatile переменной всегда видит последнее записанное значение, а synchronized обеспечивает как видимость, так и
атомарность

[К оглавлению](#Jvm)

# 58. Каким образом ключевое слово synchronized влияет на видимость и порядок выполнения?

`synchronized` обеспечивает как взаимное исключение, так и гарантии видимости и порядка выполнения, определённые Java
Memory Model. Когда поток захватывает монитор, он видит все изменения, сделанные до этого другим потоком, освободившим
этот же монитор. Это обеспечивает happens-before отношение между выходом из synchronized и входом в него другим потоком.
Также synchronized предотвращает переупорядочивание инструкций внутри блока, обеспечивая корректное поведение
многопоточного кода

[К оглавлению](#Jvm)

# 59. В чем разница между synchronized и volatile?

`volatile` в Java гарантирует видимость изменений переменной между потоками и предотвращает переупорядочивание
инструкций, но не обеспечивает атомарность составных операций. `synchronized` обеспечивает взаимное исключение,
атомарность и видимость для блока кода, но может снижать производительность из-за блокировок. Поэтому volatile подходит
для простых флагов, а synchronized — когда нужно защитить несколько связанных операций

[К оглавлению](#Jvm)

# 60. Какую роль играют happens-before отношения в JMM? Приведите пример.

Happens-before — это правило в Java Memory Model, которое гарантирует порядок операций и видимость изменений между
потоками. Если действие A happens-before действию B, то изменения из A гарантированно видны в B. Например, запись в
volatile переменную happens-before последующему чтению этой переменной другим потоком, что гарантирует корректную
синхронизацию данных без явных блокировок

[К оглавлению](#Jvm)

# 61. Какие гарантии предоставляет JMM при использовании атомарных классов из пакета java.util.concurrent?

Атомарные классы из java.util.concurrent.atomic обеспечивают атомарность операций и гарантируют видимость изменений
между потоками, используя механизмы, похожие на volatile. Все операции на атомарных объектах создают happens-before
отношения, что обеспечивает корректную синхронизацию без блокировок. Это позволяет безопасно обновлять переменные в
многопоточной среде с высокой производительностью.

[К оглавлению](#Jvm)

# 62. Что такое “reordering” и как оно влияет на многопоточность в Java?

Reordering — это оптимизация, при которой JVM, компилятор или CPU могут менять порядок выполнения инструкций для
повышения производительности. Однако в многопоточной среде это может привести к ошибкам видимости и гонкам данных, когда
один поток видит операции в другом порядке. Java Memory Model вводит правила happens-before и механизмы, такие как
volatile и synchronized, чтобы предотвратить нежелательное переупорядочивание и обеспечить корректное взаимодействие
потоков

[К оглавлению](#Jvm)

# 63. Как работает final в контексте JMM, и как это влияет на безопасную публикацию объектов?

Ключевое слово final в Java Memory Model гарантирует, что значения final-полей, установленные в конструкторе, будут
корректно видны всем потокам после публикации объекта, даже без дополнительной синхронизации. Это достигается за счет
специальных happens-before гарантий, предотвращающих переупорядочивание и обеспечивающих безопасную публикацию. В
отличие от обычных полей, значения final-полей нельзя изменить после конструктора, что позволяет избежать проблем с
видимостью и состоянием объекта

[К оглавлению](#Jvm)

# 64. Какие существуют способы публикации объекта между потоками? Примеры.

Безопасная публикация объекта между потоками достигается с помощью механизмов, обеспечивающих happens-before отношения,
таких как: final поля, volatile ссылки, синхронизированные блоки, потокобезопасные коллекции и правильная инициализация
в статическом блоке. Неправильная публикация может привести к тому, что другие потоки увидят объект в неполностью
инициалированном состоянии

[К оглавлению](#Jvm)

# 65. Объясните влияние JMM на сборщик мусора (Garbage Collector) и его взаимодействие с потоками.

Java Memory Model обеспечивает корректную видимость ссылок и порядка операций между потоками, что позволяет Garbage
Collector точно определять живые объекты и безопасно собирать мусор. JMM гарантирует happens-before отношения, которые
помогают GC видеть актуальное состояние памяти, а также обеспечивают консистентность данных в безопасных точках
остановки потоков. Благодаря этому GC и многопоточное приложение могут работать корректно и эффективно

[К оглавлению](#Jvm)

# 66. Как можно добиться безопасного завершения потоков в Java с учетом JMM?

Для безопасного завершения потоков в Java я использую volatile флаг или механизм прерывания. `volatile` гарантирует, что
изменение флага будет видно потоку в цикле благодаря happens-before отношениям Java Memory Model. Прерывание (
interrupt) — более рекомендуемый способ, так как он позволяет не только сигнализировать, но и прерывать блокирующие
операции, что тоже гарантируется JMM. Таким образом, я обеспечиваю корректное и своевременное завершение потоков

[К оглавлению](#Jvm)

# 67. Какие проблемы могут возникнуть при неправильно настроенном lazy initialization в многопоточности? Как их решить?

При неправильно настроенной ленивой инициализации в многопоточном приложении могут возникнуть проблемы с видимостью и
гонками потоков, что приведёт к созданию нескольких экземпляров или получению частично инициалированного объекта.
Решается это либо с помощью синхронизации, либо используя double-checked locking с volatile, либо паттерном с внутренним
статическим классом, который обеспечивает потокобезопасную ленивую инициализацию без лишних накладных расходов

[К оглавлению](#Jvm)

# 68. Объясните семантику happens-before в контексте чтения и записи с использованием Lock и Condition.

В контексте Lock и Condition, happens-before гарантирует, что вызов unlock() одного потока happens-before последующему
lock() другого, обеспечивая видимость изменений. Кроме того, вызов signal() на Condition happens-before возвращению из
await() у разбуженного потока, что гарантирует, что поток после ожидания увидит все изменения, сделанные перед сигналом.
Эти отношения обеспечивают корректную и безопасную синхронизацию между потоками

[К оглавлению](#Jvm)