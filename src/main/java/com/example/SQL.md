## SQL

[1. Какой SQL запрос SELECT, который выберет все записи из таблицы employees.](#1-какой-sql-запрос-select-который-выберет-все-записи-из-таблицы-employees)

[2. Какой SQL запрос UPDATE изменит зарплату сотрудника с ID 100 на 5000?](#2-какой-sql-запрос-update-изменит-зарплату-сотрудника-с-id-100-на-5000)

[3. Какой SQL запрос INSERT, который добавит нового сотрудника с именем "Anton" в таблицу employees.](#3-какой-sql-запрос-insert-который-добавит-нового-сотрудника-с-именем-anton-в-таблицу-employees)

[4. Какой SQL запрос DELETE удалит запись сотрудника с ID 200 из таблицы employees?](#4-какой-sql-запрос-delete-удалит-запись-сотрудника-с-id-200-из-таблицы-employees)

[5. Какой SQL запрос SELECT, который выберет имена и зарплаты всех сотрудников, у которых зарплата выше средней зарплаты в компании.](#5-какой-sql-запрос-select-который-выберет-имена-и-зарплаты-всех-сотрудников-у-которых-зарплата-выше-средней-зарплаты-в-компании)

[6. Какой SQL запрос UPDATE изменит должность всех сотрудников в отделе "Sales" на "Sales Manager"?](#6-какой-sql-запрос-update-изменит-должность-всех-сотрудников-в-отделе-sales-на-sales-manager)

[7. Какой SQL запрос INSERT, который добавит нового сотрудника с именем "Jane Smith", должностью "Marketing Specialist" и зарплатой 4000 в таблицу employees.](#7-какой-sql-запрос-insert-который-добавит-нового-сотрудника-с-именем-jane-smith-должностью-marketing-specialist-и-зарплатой-4000-в-таблицу-employees)

[8. Какой SQL запрос DELETE удалит всех сотрудников из отдела "HR"?](#8-какой-sql-запрос-delete-удалит-всех-сотрудников-из-отдела-hr)

[9. Какой SQL запрос SELECT, который выберет имена и зарплаты всех сотрудников, у которых зарплата выше средней зарплаты в их отделе.](#9-какой-sql-запрос-select-который-выберет-имена-и-зарплаты-всех-сотрудников-у-которых-зарплата-выше-средней-зарплаты-в-их-отделе)

[10. Какой SQL запрос UPDATE изменит должность всех сотрудников в отделе "Sales" на "Sales Manager", если их текущая должность не "Sales Manager"?](#10-какой-sql-запрос-update-изменит-должность-всех-сотрудников-в-отделе-sales-на-sales-manager-если-их-текущая-должность-не-sales-manager)

[11. Какой SQL запрос INSERT, который добавит нового сотрудника с именем "Alex Johnson", должностью "IT Specialist", зарплатой 6000 и датой приема на работу "2023-01-01" в таблицу employees.](#11-какой-sql-запрос-insert-который-добавит-нового-сотрудника-с-именем-alex-johnson-должностью-it-specialist-зарплатой-6000-и-датой-приема-на-работу-2023-01-01-в-таблицу-employees)

[12. Какой SQL запрос DELETE удалит всех сотрудников, которые не вносили вклад в проект за последние 6 месяцев?](#12-какой-sql-запрос-delete-удалит-всех-сотрудников-которые-не-вносили-вклад-в-проект-за-последние-6-месяцев)

[13. Что такое нормализация базы данных?](#13-что-такое-нормализация-базы-данных)

[14. Какие цели преследует нормализация БД?](#14-какие-цели-преследует-нормализация-бд)

[15. Назовите и опишите три формы нормализации.](#15-назовите-и-опишите-три-формы-нормализации)

[16. Какие проблемы могут возникнуть при неправильной нормализации базы данных?](#16-какие-проблемы-могут-возникнуть-при-неправильной-нормализации-базы-данных)

[17. Как нормализация помогает избежать дублирования данных?](#17-как-нормализация-помогает-избежать-дублирования-данных)

[18. Объясните, что такое функциональная зависимость в контексте нормализации БД.](#18-объясните-что-такое-функциональная-зависимость-в-контексте-нормализации-бд)

[19. Какие техники и подходы можно использовать для оптимизации процесса нормализации, чтобы минимизировать потери производительности и упростить управление данными?](#19-какие-техники-и-подходы-можно-использовать-для-оптимизации-процесса-нормализации-чтобы-минимизировать-потери-производительности-и-упростить-управление-данными)

[20. Что такое денормализация и в каких случаях она может быть полезна?](#20-что-такое-денормализация-и-в-каких-случаях-она-может-быть-полезна)

[21. Объясните концепцию BCNF (Нормальная форма Бойса-Кодда) и ее отличия от 3NF.](#21-объясните-концепцию-bcnf-нормальная-форма-бойса-кодда-и-ее-отличия-от-3nf)

[22. Что такое JOIN в контексте SQL?](#22-что-такое-join-в-контексте-sql)

[23. Какова основная разница между INNER JOIN и OUTER JOIN?](#23-какова-основная-разница-между-inner-join-и-outer-join)

[24. Для чего используется LEFT JOIN?](#24-для-чего-используется-left-join)

[25. Как можно объединить таблицы без использования JOIN, используя другие SQL конструкции?](#25-как-можно-объединить-таблицы-без-использования-join-используя-другие-sql-конструкции)

[26. Объясните, как работает RIGHT JOIN и в каких случаях его лучше использовать?](#26-объясните-как-работает-right-join-и-в-каких-случаях-его-лучше-использовать)

[27. Какие типы OUTER JOIN существуют в SQL?](#27-какие-типы-outer-join-существуют-в-sql)

[28. Как реализовать FULL OUTER JOIN, если этот тип JOIN не поддерживается напрямую?](#28-как-реализовать-full-outer-join-если-этот-тип-join-не-поддерживается-напрямую)

[29. Что такое NATURAL JOIN в SQL и как он отличается от INNER JOIN?](#29-что-такое-natural-join-в-sql-и-как-он-отличается-от-inner-join)

[30. Как использовать JOIN для оптимизации запросов с подзапросами?](#30-как-использовать-join-для-оптимизации-запросов-с-подзапросами)

[31. Какая агрегатная функция используется для вычисления среднего значения столбца?](#31-какая-агрегатная-функция-используется-для-вычисления-среднего-значения-столбца)

[32. Для чего используется агрегатная функция COUNT?](#32-для-чего-используется-агрегатная-функция-count)

[33. Как рассчитать сумму значений по определенному столбцу?](#33-как-рассчитать-сумму-значений-по-определенному-столбцу)

[34. Как применить агрегатную функцию к столбцу с условием?](#34-как-применить-агрегатную-функцию-к-столбцу-с-условием)

[35. Как объединить результаты агрегатных функций с GROUP BY?](#35-как-объединить-результаты-агрегатных-функций-с-group-by)

[36. Как использовать агрегатную функцию для вычисления общего количества уникальных значений в столбце?](#36-как-использовать-агрегатную-функцию-для-вычисления-общего-количества-уникальных-значений-в-столбце)

[37. Как реализовать оконные функции с использованием агрегатных функций?](#37-как-реализовать-оконные-функции-с-использованием-агрегатных-функций)

[38. Какие стратегии можно использовать для оптимизации запросов с агрегатными функциями на больших объемах данных?](#38-какие-стратегии-можно-использовать-для-оптимизации-запросов-с-агрегатными-функциями-на-больших-объемах-данных)

[39. Как использовать агрегатные функции в сочетании с подзапросами для решения сложных задач анализа данных?](#39-как-использовать-агрегатные-функции-в-сочетании-с-подзапросами-для-решения-сложных-задач-анализа-данных)

[40. Что такое первичный ключ в реляционной базе данных?](#40-что-такое-первичный-ключ-в-реляционной-базе-данных)

[41. Какое SQL-определение используется для установки ограничения NOT NULL на поле таблицы?](#41-какое-sql-определение-используется-для-установки-ограничения-not-null-на-поле-таблицы)

[42. Как в SQL создать таблицу с автоматически инкрементируемым полем ID?](#42-как-в-sql-создать-таблицу-с-автоматически-инкрементируемым-полем-id)

[43. Какое ограничение обеспечивает уникальность значений в столбце таблицы базы данных?](#43-какое-ограничение-обеспечивает-уникальность-значений-в-столбце-таблицы-базы-данных)

[44. Как в SQL задать ограничение, чтобы значение поля таблицы соответствовало определенному диапазону чисел?](#44-как-в-sql-задать-ограничение-чтобы-значение-поля-таблицы-соответствовало-определенному-диапазону-чисел)

[45. Как реализовать внешний ключ в SQL, указывающий на первичный ключ в другой таблице?](#45-как-реализовать-внешний-ключ-в-sql-указывающий-на-первичный-ключ-в-другой-таблице)

[46. Как в SQL использовать ограничение CHECK для определения сложных условий на значения в столбце?](#46-как-в-sql-использовать-ограничение-check-для-определения-сложных-условий-на-значения-в-столбце)

[47. Как реализовать составной первичный ключ в SQL?](#47-как-реализовать-составной-первичный-ключ-в-sql)

[48. Как в SQL ограничить доступ к определенным строкам таблицы с использованием политик безопасности?](#48-как-в-sql-ограничить-доступ-к-определенным-строкам-таблицы-с-использованием-политик-безопасности)

[49. Для чего используются индексы в реляционных базах данных?](#49-для-чего-используются-индексы-в-реляционных-базах-данных)

[50. Что такое кластеризованный и некластеризованный индекс?](#50-что-такое-кластеризованный-и-некластеризованный-индекс)

[51. Какие плюсы и минусы вы можете выделить при использовании индексов?](#51-какие-плюсы-и-минусы-вы-можете-выделить-при-использовании-индексов)

[52. Какие принципы нужно соблюдать при проектировании составного индекса?](#52-какие-принципы-нужно-соблюдать-при-проектировании-составного-индекса)

[53. Какие есть структуры для хранения индекса?](#53-какие-есть-структуры-для-хранения-индекса)

[54. Опишите разницу между индексами B-дерева и хеш-индексами. В каких случаях предпочтительно использовать каждый из них?](#54-опишите-разницу-между-индексами-b-дерева-и-хеш-индексами-в-каких-случаях-предпочтительно-использовать-каждый-из-них)

[55. Как работает индекс с использованием внешних функций (например, lower()) и как это влияет на производительность запросов?](#55-как-работает-индекс-с-использованием-внешних-функций-например-lower-и-как-это-влияет-на-производительность-запросов)

[56. В чем особенности использования индексов в распределенных базах данных?](#56-в-чем-особенности-использования-индексов-в-распределенных-базах-данных)

[57. Опишите, что такое хранимая процедура в контексте SQL.](#57-опишите-что-такое-хранимая-процедура-в-контексте-sql)

[58. Как можно создать простейшую функцию в SQL?](#58-как-можно-создать-простейшую-функцию-в-sql)

[59. Что такое триггер в базах данных и для чего он используется?](#59-что-такое-триггер-в-базах-данных-и-для-чего-он-используется)

[60. Какие преимущества использования хранимых процедур перед кодом на стороне клиента?](#60-какие-преимущества-использования-хранимых-процедур-перед-кодом-на-стороне-клиента)

[61. Как передать параметры в SQL функцию и использовать их внутри неё?](#61-как-передать-параметры-в-sql-функцию-и-использовать-их-внутри-неё)

[62. Какие типы триггеров существуют и в чем их основные отличия?](#62-какие-типы-триггеров-существуют-и-в-чем-их-основные-отличия)

[63. Как можно использовать транзакции внутри хранимых процедур для управления изменениями в базе данных?](#63-как-можно-использовать-транзакции-внутри-хранимых-процедур-для-управления-изменениями-в-базе-данных)

[64. Как создать функцию, которая возвращает таблицу в SQL?](#64-как-создать-функцию-которая-возвращает-таблицу-в-sql)

[65. Каким образом можно обработать исключения внутри триггера и каковы лучшие практики для их использования?](#65-каким-образом-можно-обработать-исключения-внутри-триггера-и-каковы-лучшие-практики-для-их-использования)

[66. Что такое план запроса в контексте SQL?](#66-что-такое-план-запроса-в-контексте-sql)

[67. Как можно просмотреть план запроса в SQL?](#67-как-можно-просмотреть-план-запроса-в-sql)

[68. Почему важно понимать план запроса при оптимизации запросов?](#68-почему-важно-понимать-план-запроса-при-оптимизации-запросов)

[69. Какие типы операций можно найти в плане запроса?](#69-какие-типы-операций-можно-найти-в-плане-запроса)

[70. Как индексы влияют на план запроса?](#70-как-индексы-влияют-на-план-запроса)

[71. Какие факторы могут влиять на выбор оптимизатора при составлении плана запроса?](#71-какие-факторы-могут-влиять-на-выбор-оптимизатора-при-составлении-плана-запроса)

[72. Какие существуют методы оценки стоимости выполнения запроса?](#72-какие-существуют-методы-оценки-стоимости-выполнения-запроса)

[73. Как можно влиять на выбор плана запроса без изменения самого запроса?](#73-как-можно-влиять-на-выбор-плана-запроса-без-изменения-самого-запроса)

[74. Как производится оптимизация запросов на основе плана запроса?](#74-как-производится-оптимизация-запросов-на-основе-плана-запроса)

[75. Что означает аббревиатура ACID в контексте транзакций в базах данных?](#75-что-означает-аббревиатура-acid-в-контексте-транзакций-в-базах-данных)

[76. Что такое транзакция в контексте баз данных?](#76-что-такое-транзакция-в-контексте-баз-данных)

[77. Какие основные уровни изолированности существуют?](#77-какие-основные-уровни-изолированности-существуют)

[78. Каковы основные различия между уровнями изолированности транзакций READ UNCOMMITTED и READ COMMITTED?](#78-каковы-основные-различия-между-уровнями-изолированности-транзакций-read-uncommitted-и-read-committed)

[79. Как SERIALIZABLE уровень изолированности влияет на выполнение транзакций?](#79-как-serializable-уровень-изолированности-влияет-на-выполнение-транзакций)

[80. Какие стратегии и подходы используются для оптимизации производительности при работе с транзакциями?](#80-какие-стратегии-и-подходы-используются-для-оптимизации-производительности-при-работе-с-транзакциями)

[81. Как можно реализовать механизм оптимистической блокировки в контексте управления транзакциями?](#81-как-можно-реализовать-механизм-оптимистической-блокировки-в-контексте-управления-транзакциями)

[82. Какие стратегии и подходы используются для оптимизации производительности при работе с транзакциями в распределенных системах?](#82-какие-стратегии-и-подходы-используются-для-оптимизации-производительности-при-работе-с-транзакциями-в-распределенных-системах)

[83. Как можно обеспечить атомарность транзакций, выполняющихся параллельно, без ухудшения производительности?](#83-как-можно-обеспечить-атомарность-транзакций-выполняющихся-параллельно-без-ухудшения-производительности)

[84. Что такое репликация в контексте реляционных баз данных?](#84-что-такое-репликация-в-контексте-реляционных-баз-данных)

[85. Почему шардирование может быть полезным для больших баз данных?](#85-почему-шардирование-может-быть-полезным-для-больших-баз-данных)

[86. Каковы основные цели партиционирования данных?](#86-каковы-основные-цели-партиционирования-данных)

[87. Какие существуют типы репликации в реляционных базах данных и в чем их различия?](#87-какие-существуют-типы-репликации-в-реляционных-базах-данных-и-в-чем-их-различия)

[88. Какие проблемы могут возникнуть при шардировании базы данных и как их можно решить?](#88-какие-проблемы-могут-возникнуть-при-шардировании-базы-данных-и-как-их-можно-решить)

[89. Какие существуют стратегии партиционирования таблиц в реляционных базах данных?](#89-какие-существуют-стратегии-партиционирования-таблиц-в-реляционных-базах-данных)

[90. Опишите процесс настройки мастер-слейв репликации в реляционной базе данных.](#90-опишите-процесс-настройки-мастер-слейв-репликации-в-реляционной-базе-данных)

[91. В чем заключается проблема горячих точек при шардировании и какие подходы могут помочь в ее решении?](#91-в-чем-заключается-проблема-горячих-точек-при-шардировании-и-какие-подходы-могут-помочь-в-ее-решении)

[92. Как партиционирование данных может влиять на производительность запросов в реляционных базах данных и при каких условиях это эффект наиболее заметен?](#92-как-партиционирование-данных-может-влиять-на-производительность-запросов-в-реляционных-базах-данных-и-при-каких-условиях-это-эффект-наиболее-заметен)

[93. Что такое SQL инъекция?](#93-что-такое-sql-инъекция)

[94. Какие могут быть последствия использования SQL инъекций?](#94-какие-могут-быть-последствия-использования-sql-инъекций)

[95. В каких случаях приложение может быть уязвимо к SQL инъекциям?](#95-в-каких-случаях-приложение-может-быть-уязвимо-к-sql-инъекциям)

[96. Как можно предотвратить SQL инъекции при использовании динамически формируемых запросов?](#96-как-можно-предотвратить-sql-инъекции-при-использовании-динамически-формируемых-запросов)

[97. Какие методы предотвращения SQL инъекций существуют в Java?](#97-какие-методы-предотвращения-sql-инъекций-существуют-в-java)

[98. Как работает PreparedStatement в Java в контексте предотвращения SQL инъекций?](#98-как-работает-preparedstatement-в-java-в-контексте-предотвращения-sql-инъекций)

[99. Какие существуют специфичные техники обнаружения SQL инъекций при проведении тестирования на проникновение?](#99-какие-существуют-специфичные-техники-обнаружения-sql-инъекций-при-проведении-тестирования-на-проникновение)

[100. Как можно использовать Content Security Policy для защиты от SQL инъекций?](#100-как-можно-использовать-content-security-policy-для-защиты-от-sql-инъекций)

[101. Какие существуют методы автоматизации обнаружения уязвимостей к SQL инъекциям в больших системах?](#101-какие-существуют-методы-автоматизации-обнаружения-уязвимостей-к-sql-инъекциям-в-больших-системах)

[102. Что такое SQL?](#102-что-такое-sql)

[103. Какие операции можно выполнять с помощью DML?](#103-какие-операции-можно-выполнять-с-помощью-dml)

[104. Чем отличается DDL от DML?](#104-чем-отличается-ddl-от-dml)

[105. Как можно изменить структуру таблицы, используя DDL?](#105-как-можно-изменить-структуру-таблицы-используя-ddl)

[106. Приведите пример команды DCL.](#106-приведите-пример-команды-dcl)

[107. Какие транзакции поддерживает TCL и как их использовать](#107-какие-транзакции-поддерживает-tcl-и-как-их-использовать)

[108. Какие стратегии оптимизации запросов вы знаете?](#108-какие-стратегии-оптимизации-запросов-вы-знаете)

[109. Как реализовать версионирование данных в реляционной базе данных?](#109-как-реализовать-версионирование-данных-в-реляционной-базе-данных)

[110. Приведите пример использования всех четырёх типов команд (DDL, DML, DCL, TCL) в рамках одного бизнес-ценария.](#110-приведите-пример-использования-всех-четырёх-типов-команд-ddl-dml-dcl-tcl-в-рамках-одного-бизнес-ценария)

# 1. Какой SQL запрос SELECT, который выберет все записи из таблицы employees.

Чтобы получить все записи из таблицы employees, используется базовый запрос `SELECT * FROM employees;`. Звездочка здесь
указывает на выбор всех столбцов. На практике, чтобы оптимизировать работу, лучше явно указывать нужные поля вместо `*`,
особенно если таблица большая и не все данные нужны.

[К оглавлению](#SQL)

# 2. Какой SQL запрос UPDATE изменит зарплату сотрудника с ID 100 на 5000?

Для того чтобы обновить зарплату сотрудника с ID 100, мы используем запрос
`UPDATE employees SET salary = 5000 WHERE employee_id = 100;`. Важно помнить, что без оператора `WHERE` запрос изменит
все строки в таблице, что может привести к ошибке. Обычно рекомендуется проверять результаты выполнения запроса на
тестовых данных, чтобы избежать случайных изменений.

[К оглавлению](#SQL)

# 3. Какой SQL запрос INSERT, который добавит нового сотрудника с именем "Anton" в таблицу employees.

Чтобы добавить нового сотрудника с именем Anton, используется `INSERT INTO employees (name) VALUES ('Anton');`. При этом
важно учитывать структуру таблицы: если в ней есть NOT NULL поля без значений по умолчанию, их нужно обязательно
указать. Также, если используется автоинкрементное поле ID, его можно опустить, и оно заполнится автоматически

[К оглавлению](#SQL)

# 4. Какой SQL запрос DELETE удалит запись сотрудника с ID 200 из таблицы employees?

Запрос для удаления записи сотрудника с ID 200 выглядит так: `DELETE FROM employees WHERE employee_id = 200;`. Важно
помнить, что без оператора WHERE запрос удаляет все строки в таблице, что может привести к утрате данных. Также перед
выполнением таких операций рекомендуется создавать резервные копии данных и выполнять их на тестовых данных, чтобы
предотвратить ошибки.

[К оглавлению](#SQL)

# 5. Какой SQL запрос SELECT, который выберет имена и зарплаты всех сотрудников, у которых зарплата выше средней зарплаты в компании.

Чтобы выбрать сотрудников с зарплатой выше средней, используется подзапрос:
`SELECT name, salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);`. Это типичный пример
коррелированного фильтра через агрегатную функцию. Такие запросы позволяют сравнивать значения по отношению ко всей
выборке, что часто используется в аналитических задачах

[К оглавлению](#SQL)

# 6. Какой SQL запрос UPDATE изменит должность всех сотрудников в отделе "Sales" на "Sales Manager"?

Чтобы изменить должность всех сотрудников в отделе Sales на Sales Manager, используем запрос
`UPDATE employees SET position = 'Sales Manager' WHERE department = 'Sales';`. Важно помнить, что без оператора WHERE
запрос обновит должность всех сотрудников в таблице, что может привести к ошибке. Также в реальных приложениях важно
учитывать транзакционность таких операций и их тестирование на небольших данных

[К оглавлению](#SQL)

# 7. Какой SQL запрос INSERT, который добавит нового сотрудника с именем "Jane Smith", должностью "Marketing Specialist" и зарплатой 4000 в таблицу employees.

Для добавления нового сотрудника в таблицу employees используется запрос
`INSERT INTO employees (name, position, salary) VALUES ('Jane Smith', 'Marketing Specialist', 4000);`. Явное указание
полей — это хорошая практика: она повышает читаемость и защищает от ошибок, если структура таблицы изменится. Также
важно помнить про автоинкрементные поля и значения по умолчанию — их можно не указывать, если это предусмотрено схемой

[К оглавлению](#SQL)

# 8. Какой SQL запрос DELETE удалит всех сотрудников из отдела "HR"?

"Чтобы удалить всех сотрудников из отдела HR, используется запрос `DELETE FROM employees WHERE department = 'HR';`.
Очень важно использовать WHERE, иначе без него будет удалена вся таблица. В реальных проектах такие действия обязательно
оборачиваются в транзакции, чтобы можно было откатить удаление в случае ошибки, и предварительно логируются для аудита

[К оглавлению](#SQL)

# 9. Какой SQL запрос SELECT, который выберет имена и зарплаты всех сотрудников, у которых зарплата выше средней зарплаты в их отделе.

Чтобы выбрать сотрудников с зарплатой выше средней по их отделу, я использую коррелированный подзапрос:
`SELECT e.name, e.salary FROM employees e WHERE e.salary > (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department = e.department);`.
Такой подход позволяет сравнивать значения внутри подгрупп (в данном случае — по отделам). Важно учитывать
производительность: коррелированные подзапросы могут работать медленно на больших объемах данных, и в таких случаях
стоит рассмотреть использование оконных функций или предварительных CTE

[К оглавлению](#SQL)

# 10. Какой SQL запрос UPDATE изменит должность всех сотрудников в отделе "Sales" на "Sales Manager", если их текущая должность не "Sales Manager"?

Чтобы обновить должность сотрудников в отделе Sales, только если их текущая должность не является Sales Manager, я
использую запрос
`UPDATE employees SET position = 'Sales Manager' WHERE department = 'Sales' AND position != 'Sales Manager';`. Такое
условие позволяет избежать лишних операций обновления для сотрудников, которые уже находятся на нужной должности. Это
особенно важно для оптимизации работы базы данных.

[К оглавлению](#SQL)

# 11. Какой SQL запрос INSERT, который добавит нового сотрудника с именем "Alex Johnson", должностью "IT Specialist", зарплатой 6000 и датой приема на работу "2023-01-01" в таблицу employees.

Для добавления нового сотрудника с данными Alex Johnson, IT Specialist, зарплатой 6000 и датой приема на работу
2023-01-01, использую запрос
`INSERT INTO employees (name, position, salary, hire_date) VALUES ('Alex Johnson', 'IT Specialist', 6000, '2023-01-01');`.
Очень важно всегда указывать явные имена полей, чтобы код был более читаемым и устойчивым к изменениям структуры таблицы

[К оглавлению](#SQL)

# 12. Какой SQL запрос DELETE удалит всех сотрудников, которые не вносили вклад в проект за последние 6 месяцев?

Для удаления сотрудников, которые не вносили вклад в проект за последние 6 месяцев, я использую подзапрос с выборкой
уникальных сотрудников из таблицы project_contributions, фильтруя по дате. Запрос будет выглядеть так:
`DELETE FROM employees WHERE employee_id NOT IN (SELECT DISTINCT employee_id FROM project_contributions WHERE contribution_date >= CURRENT_DATE - INTERVAL '6 months');`.
Важно отметить, что такие операции лучше проводить в рамках транзакции, чтобы можно было откатить изменения в случае
ошибки, а также тестировать запросы на выборке, чтобы избежать нежелательных удалений

[К оглавлению](#SQL)

# 13. Что такое нормализация базы данных?

Нормализация базы данных — это процесс приведения структуры базы данных к такой форме, при которой данные не содержат
избыточности, и устраняются возможные аномалии при вставке, обновлении и удалении данных. Нормализация включает
несколько нормальных форм: 1NF, 2NF, 3NF, и более строгие BCNF и 4NF. Главное преимущество нормализации — это улучшение
целостности данных и упрощение их поддержки. Однако, важно помнить, что для повышения производительности, в некоторых
случаях может быть полезно использовать денормализацию

[К оглавлению](#SQL)

# 14. Какие цели преследует нормализация БД?

Основная цель нормализации базы данных — это снижение избыточности данных, что помогает сэкономить место и предотвращает
возможные ошибки при обновлении, вставке или удалении информации. Также нормализация способствует улучшению целостности
данных и предотвращению аномалий, таких как проблемы с обновлением или потерей данных. Это также улучшает анализ данных,
делает структуру базы более гибкой и упрощает дальнейшую работу с ней

[К оглавлению](#SQL)

# 15. Назовите и опишите три формы нормализации.

Первая нормальная форма устраняет повторяющиеся группы и требует атомарности. Вторая — устраняет частичные зависимости
от составного ключа, а третья — транзитивные зависимости, то есть все поля должны зависеть только от первичного ключа и
никак иначе. Эти формы позволяют избежать аномалий при вставке, обновлении и удалении, а также делают структуру данных
логичной и гибкой для масштабирования

[К оглавлению](#SQL)

# 16. Какие проблемы могут возникнуть при неправильной нормализации базы данных?

При неправильной нормализации базы данных могут возникнуть несколько серьезных проблем. Избыточность данных и аномалии
вставки, обновления и удаления могут значительно ухудшить производительность и усложнить поддержку базы. Например,
дублирование данных ведет к необходимости обновления их в нескольких местах, что увеличивает риск ошибок. Также
трудности с поддержанием целостности данных могут привести к несоответствиям и затруднениям при анализе. Для того чтобы
избежать этих проблем, важно следовать принципам нормализации и использовать их в зависимости от нужд проекта

[К оглавлению](#SQL)

# 17. Как нормализация помогает избежать дублирования данных?

Нормализация помогает избежать дублирования данных, разделяя информацию на несколько таблиц. Это устраняет избыточность
и позволяет хранить каждый элемент данных в одном месте, что упрощает обновление, улучшает целостность данных и повышает
производительность базы. Например, при нормализации мы разделяем информацию о клиентах, заказах и товарах, сохраняя
данные о каждом клиенте только один раз и связывая их с другими таблицами с помощью внешних ключей

[К оглавлению](#SQL)

# 18. Объясните, что такое функциональная зависимость в контексте нормализации БД.

Функциональная зависимость описывает, как атрибуты в таблице зависят друг от друга. Важно, что если атрибут X
функционально определяет атрибут Y, то знание X позволяет однозначно определить значение Y. Для нормализации базы данных
это ключевая концепция. Мы устраняем частичные и транзитивные зависимости, что помогает избежать дублирования данных и
улучшает структуру базы данных.

[К оглавлению](#SQL)

# 19. Какие техники и подходы можно использовать для оптимизации процесса нормализации, чтобы минимизировать потери производительности и упростить управление данными?

Нормализация базы данных требует баланса между целостностью данных и производительностью. Важно не только соблюдать
нормальные формы, но и применять такие техники, как денормализация, индексация, партиционирование и кэширование, чтобы
минимизировать потери в производительности. Я также учитываю требования бизнеса и часто использую мониторинг запросов
для оптимизации производительности базы данных в процессе эксплуатации

[К оглавлению](#SQL)

# 20. Что такое денормализация и в каких случаях она может быть полезна?

Денормализация — это процесс, при котором мы объединяем данные из нескольких таблиц для ускорения операций чтения,
снижая количество необходимых соединений между таблицами. Это полезно в системах, где важна высокая скорость чтения и
выполнение сложных запросов. Однако денормализация увеличивает избыточность данных и может привести к трудностям с их
обновлением. Поэтому она используется, когда критична производительность чтения, а не частота обновлений данных.

[К оглавлению](#SQL)

# 21. Объясните концепцию BCNF (Нормальная форма Бойса-Кодда) и ее отличия от 3NF.

BCNF — это более строгая версия 3NF, которая требует, чтобы каждая функциональная зависимость в таблице была вызвана
суперкандидатным ключом (это набор одного или нескольких атрибутов таблицы, который уникально идентифицирует каждую
строку (запись) в таблице). То есть, если у вас есть суперкандидатный ключ, то не может быть двух строк с одинаковыми
значениями этого набора атрибутов.). Это устраняет зависимости, которые могут возникнуть в 3NF, и помогает избежать
избыточности
данных. В отличие от 3NF, где допустимы некоторые транзитивные зависимости между неключевыми атрибутами, BCNF исключает
такие зависимости, обеспечивая еще более высокую степень нормализации. Однако, несмотря на свою строгость, BCNF может
увеличить сложность запросов и негативно сказаться на производительности в системах с частыми операциями вставки и
обновления.

[К оглавлению](#SQL)

# 22. Что такое JOIN в контексте SQL?

OIN в SQL — это операция, которая позволяет объединять строки из разных таблиц по общим ключам, позволяя работать с
распределёнными данными. Важнейшие виды — INNER JOIN, который возвращает только совпадающие строки, LEFT JOIN для всех
из левой таблицы и совпадений справа, и FULL JOIN, объединяющий все записи с обеих сторон. Понимание JOIN важно для
работы с реляционными базами, поскольку позволяет эффективно извлекать связные данные, минимизируя избыточность и
поддерживая целостность

[К оглавлению](#SQL)

# 23. Какова основная разница между INNER JOIN и OUTER JOIN?

Основная разница в том, что INNER JOIN возвращает только те строки, у которых есть совпадение по ключу в обеих таблицах,
тогда как OUTER JOIN включает и те строки, для которых совпадения нет — добавляя NULL в поля отсутствующей стороны

[К оглавлению](#SQL)

# 24. Для чего используется LEFT JOIN?

LEFT JOIN используется, когда нужно вернуть все строки из левой таблицы, независимо от того, есть ли для них совпадения
в правой. Это особенно полезно для поиска отсутствующих данных — например, сотрудников без отдела или клиентов без
заказов

[К оглавлению](#SQL)

# 25. Как можно объединить таблицы без использования JOIN, используя другие SQL конструкции?

Для объединения таблиц без использования JOIN можно использовать несколько подходов, таких как подзапросы, оператор
UNION, CROSS JOIN, или WITH для создания временных таблиц. Эти методы дают возможность извлекать или комбинировать
данные без явного соединения, что может быть полезно в специфичных случаях, например, для объединения результатов разных
запросов или для создания декартового произведения.

[К оглавлению](#SQL)

# 26. Объясните, как работает RIGHT JOIN и в каких случаях его лучше использовать?

RIGHT JOIN возвращает все строки из правой таблицы и совпадающие из левой. Если в левой таблице нет соответствующих
данных, поля заполняются NULL. Это удобно, когда нам нужно получить полную картину по правой таблице — например, все
отделы, даже если в них нет сотрудников. Обычно используется как альтернатива LEFT JOIN, если логика или читаемость
запроса требует сохранить акцент на правой таблице.

[К оглавлению](#SQL)

# 27. Какие типы OUTER JOIN существуют в SQL?

В SQL есть три типа OUTER JOIN: LEFT, RIGHT и FULL. LEFT JOIN возвращает все строки из левой таблицы и совпадения из
правой. RIGHT JOIN — наоборот. FULL OUTER JOIN объединяет обе таблицы, возвращая все строки независимо от совпадений.
Они полезны, когда важны даже неполные или отсутствующие данные — например, сотрудники без отдела или отделы без
сотрудников

[К оглавлению](#SQL)

# 28. Как реализовать FULL OUTER JOIN, если этот тип JOIN не поддерживается напрямую?

FULL OUTER JOIN можно реализовать вручную, если он не поддерживается СУБД. Для этого объединяют LEFT JOIN и RIGHT JOIN
через UNION, чтобы включить все совпадающие и несовпадающие строки из обеих таблиц. Это полезно, например, в MySQL, где
FULL JOIN отсутствует. Если нужна оптимизация, можно использовать UNION ALL с фильтрацией дубликатов.

[К оглавлению](#SQL)

# 29. Что такое NATURAL JOIN в SQL и как он отличается от INNER JOIN?

NATURAL JOIN — это вид соединения, при котором SQL сам определяет общие столбцы по совпадению имён и строит INNER JOIN
по ним. В отличие от INNER JOIN, где мы явно указываем поля через ON, NATURAL JOIN делает это автоматически. Это
выглядит лаконично, но на практике почти не используется, потому что может привести к ошибкам при совпадении не тех
столбцов и делает запросы менее читаемыми и предсказуемыми.

[К оглавлению](#SQL)

# 30. Как использовать JOIN для оптимизации запросов с подзапросами?

JOIN может использоваться для оптимизации подзапросов, особенно когда подзапросы находятся в SELECT или WHERE и
выполняются построчно. Заменяя их на JOIN, мы можем сократить количество операций чтения, задействовать индексы и
позволить оптимизатору построить более эффективный план выполнения. Например, подзапрос в SELECT для получения названия
отдела по department_id можно заменить на JOIN с таблицей departments, что в большинстве случаев будет значительно
быстрее

[К оглавлению](#SQL)

# 31. Какая агрегатная функция используется для вычисления среднего значения столбца?

Для вычисления среднего значения используется агрегатная функция AVG(). Она возвращает среднее арифметическое по
числовому столбцу, игнорируя NULL. Например: `SELECT AVG(salary) FROM employees` покажет среднюю зарплату сотрудников

[К оглавлению](#SQL)

# 32. Для чего используется агрегатная функция COUNT?

COUNT — это агрегатная функция, которая используется для подсчёта количества строк. COUNT(*) считает все строки, включая
строки с NULL. COUNT(column) — только те, где столбец не NULL. А COUNT(DISTINCT column) — количество уникальных
значений. Она широко применяется в аналитике, например при группировке по отделам, подсчёте заказов и т.д.

[К оглавлению](#SQL)

# 33. Как рассчитать сумму значений по определенному столбцу?

Чтобы посчитать сумму значений в столбце, используется агрегатная функция SUM(). Она возвращает сумму всех не-NULL
значений. Например: `SELECT SUM(salary) FROM employees` — вернёт общую сумму зарплат. Можно применять вместе с WHERE,
GROUP BY и HAVING для аналитических запросов

[К оглавлению](#SQL)

# 34. Как применить агрегатную функцию к столбцу с условием?

Агрегатные функции можно применять с условиями с помощью WHERE, чтобы ограничить строки, к которым применяется функция.
Например: `SELECT SUM(salary) FROM employees WHERE department_id = 2` — суммирует зарплаты только в отделе 2. Если нужно
агрегировать по разным условиям одновременно — можно использовать CASE внутри агрегатной функции

[К оглавлению](#SQL)

# 35. Как объединить результаты агрегатных функций с GROUP BY?

GROUP BY используется для группировки строк по значению одного или нескольких столбцов, а агрегатные функции — чтобы
вычислить сводную информацию по каждой группе. Например, SUM(salary) по department_id даст сумму зарплат в каждом
отделе. При необходимости фильтрации по агрегатным значениям используется HAVING, например
`HAVING SUM(salary) > 100000`. Такой подход помогает строить отчёты и анализировать данные по категориям

[К оглавлению](#SQL)

# 36. Как использовать агрегатную функцию для вычисления общего количества уникальных значений в столбце?

Чтобы посчитать количество уникальных значений в столбце, используется COUNT(DISTINCT column). Например:
`SELECT COUNT(DISTINCT department_id) FROM employees` — это количество уникальных отделов. Если нужно посчитать
уникальные комбинации нескольких столбцов, в PostgreSQL можно использовать COUNT(DISTINCT (col1, col2)), а в других
СУБД — использовать подзапрос с GROUP BY

[К оглавлению](#SQL)

# 37. Как реализовать оконные функции с использованием агрегатных функций?

Оконные функции позволяют применять агрегатные функции к строкам, не группируя их. Они пишутся как AGG_FUNC(...)
OVER (...), где через PARTITION BY задаются группы, а через ORDER BY — порядок внутри окна. Например:
`SUM(salary) OVER (PARTITION BY department_id)` посчитает сумму зарплат по отделу для каждой строки. Это мощный
инструмент для аналитики — позволяет ранжировать, сравнивать и накапливать значения без потери строк

[К оглавлению](#SQL)

# 38. Какие стратегии можно использовать для оптимизации запросов с агрегатными функциями на больших объемах данных?

Для ускорения агрегатных запросов я использую индексы на колонках фильтрации, предагрегированные таблицы или
materialized views, оконные функции вместо вложенных подзапросов, а также partitioning по дате или ID. Если нужна
высокая производительность при большом объёме данных — использую approximate-агрегаты, параллелизм и правильный выбор
типов данных. Главное — уменьшить объём обрабатываемых строк до агрегации и использовать анализ EXPLAIN PLAN для
выявления узких мест

[К оглавлению](#SQL)

# 39. Как использовать агрегатные функции в сочетании с подзапросами для решения сложных задач анализа данных?

Агрегатные функции часто используются внутри подзапросов для аналитики: например, чтобы сравнить строки с агрегатными
значениями (salary > AVG(salary) по отделу), найти максимумы, суммы и средние значения в группах. Обычно я применяю
подзапросы в WHERE, FROM или SELECT, в зависимости от того, нужно ли фильтровать, присоединить агрегированные данные или
просто отобразить их. Такой подход — мощный инструмент для построения аналитических отчётов и сложной бизнес-логики

[К оглавлению](#SQL)

# 40. Что такое первичный ключ в реляционной базе данных?

Первичный ключ — это уникальный идентификатор каждой записи в таблице, который гарантирует, что ни одна строка не
повторяется и не содержит NULL. Он обеспечивает целостность данных и используется для связи таблиц через внешние ключи.
В таблице может быть только один первичный ключ, который может быть составным, если нужен уникальный идентификатор из
нескольких колонок

[К оглавлению](#SQL)

# 41. Какое SQL-определение используется для установки ограничения NOT NULL на поле таблицы?

Ограничение NOT NULL указывается при создании столбца, чтобы гарантировать, что в него нельзя записать пустое значение.
Это важно для обеспечения целостности данных, когда поле обязательно должно содержать значение. Например,
`name VARCHAR(100) NOT NULL`

[К оглавлению](#SQL)

# 42. Как в SQL создать таблицу с автоматически инкрементируемым полем ID?

Автоинкремент — это специальное свойство столбца, при котором его значение автоматически увеличивается при добавлении
новой записи. В MySQL для этого используют AUTO_INCREMENT, в PostgreSQL — SERIAL или GENERATED AS IDENTITY, в SQL
Server — IDENTITY. Это удобно для создания уникальных ключей без ручного задания

[К оглавлению](#SQL)

# 43. Какое ограничение обеспечивает уникальность значений в столбце таблицы базы данных?

Для обеспечения уникальности значений в столбце используется ограничение UNIQUE. Оно гарантирует, что в столбце не будет
повторяющихся значений, что важно для таких данных, как email или номер телефона. В отличие от первичного ключа, UNIQUE
допускает NULL, и в таблице может быть несколько уникальных ограничений

[К оглавлению](#SQL)

# 44. Как в SQL задать ограничение, чтобы значение поля таблицы соответствовало определенному диапазону чисел?

Ограничение CHECK используется для проверки значений в столбце, чтобы они соответствовали определенным условиям.
Например, можно задать диапазон чисел для зарплаты или возраста. `CHECK (salary BETWEEN 1000 AND 10000)`, чтобы
гарантировать, что зарплата сотрудника лежит в пределах указанного диапазона

[К оглавлению](#SQL)

# 45. Как реализовать внешний ключ в SQL, указывающий на первичный ключ в другой таблице?

Внешний ключ — это ограничение, связывающее столбец в одной таблице с первичным ключом другой таблицы для обеспечения
ссылочной целостности. Его можно задать как при создании таблицы, так и с помощью ALTER TABLE. Также важно указывать
поведение при удалении или обновлении связанных записей, например, каскадное удаление или установку NULL

[К оглавлению](#SQL)

# 46. Как в SQL использовать ограничение CHECK для определения сложных условий на значения в столбце?

Ограничение CHECK позволяет задавать сложные условия для проверки данных на уровне базы, используя логические операторы
и сравнения. Например, можно проверить, что зарплата либо отсутствует, либо лежит в заданном диапазоне, и одновременно
проверить, что идентификатор отдела положителен. Это помогает гарантировать корректность и валидность данных

[К оглавлению](#SQL)

# 47. Как реализовать составной первичный ключ в SQL?

Составной первичный ключ — это ключ, состоящий из нескольких столбцов, который гарантирует уникальность комбинации
значений. Например, в таблице записей о зачислениях студентов в курсы первичным ключом может быть пара (student_id,
course_id). Такой ключ удобно использовать, когда уникальность нельзя обеспечить одним столбцом

[К оглавлению](#SQL)

# 48. Как в SQL ограничить доступ к определенным строкам таблицы с использованием политик безопасности?

Для ограничения доступа к определенным строкам таблицы используют политику безопасности на уровне строк (Row-Level
Security). Например, в PostgreSQL можно включить RLS и задать политику с условием, которое фильтрует данные по нужному
признаку, например, по отделу пользователя. Это позволяет гибко управлять доступом к данным без изменения приложений

[К оглавлению](#SQL)

# 49. Для чего используются индексы в реляционных базах данных?

Индексы — это структуры данных, которые позволяют быстро находить нужные строки в таблице без полного сканирования. Они
существенно ускоряют SELECT-запросы с условиями по индексируемым столбцам. Однако индексам есть компромисс — они требуют
дополнительного места и замедляют операции записи, потому что при изменении данных индексы тоже нужно обновлять

[К оглавлению](#SQL)

# 50. Что такое кластеризованный и некластеризованный индекс?

Кластеризованный индекс определяет физический порядок хранения данных в таблице и может быть только один на таблицу.
Некластеризованный индекс — это отдельная структура, которая хранит ключи и ссылки на данные, и таких индексов может
быть несколько. Кластеризованные индексы полезны для часто запрашиваемых диапазонов, а некластеризованные — для быстрого
поиска по другим полям

[К оглавлению](#SQL)

# 51. Какие плюсы и минусы вы можете выделить при использовании индексов?

Индексы — это мощный инструмент для ускорения выборок и JOIN, а также для обеспечения уникальности данных. Однако они
требуют дополнительного места и могут замедлять операции записи из-за необходимости обновления структур индексов. Важно
находить баланс, чтобы индексировать часто используемые поля, но не перегружать таблицу лишними индексами

[К оглавлению](#SQL)

# 52. Какие принципы нужно соблюдать при проектировании составного индекса?

При проектировании составного индекса важно правильно учитывать порядок столбцов в зависимости от того, как часто и в
каком порядке они используются в запросах. Например, для запросов, которые фильтруют данные по столбцам A и B, индекс
на (A, B) может быть эффективным. Также нужно учитывать частоту изменений данных и избегать индексации столбцов с низкой
уникальностью, чтобы не снизить производительность

[К оглавлению](#SQL)

# 53. Какие есть структуры для хранения индекса?

`B-деревья (B-Tree)`

- Самая распространённая структура для индексирования.
- Это сбалансированное дерево, где данные отсортированы, и все листья находятся на одном уровне.
- Быстро выполняет операции поиска, вставки и удаления за логарифмическое время — O(log n).
- Используется для индексов, которые должны поддерживать упорядоченный доступ (например, для операций BETWEEN, <, >,
  ORDER BY).
- В PostgreSQL и большинстве СУБД — индекс по умолчанию именно B-Tree.

`B+ деревья (B+ Tree)`

- Вариация B-дерева, в которой все данные хранятся в листьях, а внутренние узлы содержат только ключи.
- Листовые узлы связаны между собой, что облегчает последовательный доступ к данным.
- Часто считается оптимальным для дисковых систем.
- Многие СУБД используют именно B+ деревья для индексов.

`Хэш-индексы (Hash Indexes)`

- Индекс строится на основе хэш-функции от ключа.
- Очень быстрый поиск по точному совпадению (=).
- Не поддерживают диапазонные запросы (BETWEEN, <, >).
- В PostgreSQL есть поддержка хэш-индексов, но они менее популярны из-за ограничений.
- Хорошо подходят для равенств.

`Индексы на основе дерева R (R-Tree)`

- Используются для индексирования пространственных данных (геометрия, координаты, полигоны).
- Поддерживают быстрый поиск по диапазонам в многомерном пространстве.
- Часто применяются в GIS-системах.

`Bitmap-индексы`

- Представляют индекс в виде битовых векторов.
- Эффективны для столбцов с низкой кардинальностью (мало уникальных значений).
- Используются в аналитических базах данных и хранилищах данных.
- Неэффективны для OLTP-систем с частыми обновлениями.

`GIN (Generalized Inverted Index) и GiST (Generalized Search Tree)`

- Специализированные индексы в PostgreSQL.
- GIN — для полнотекстового поиска и индексирования массивов, JSON, документов.
- GiST — универсальная структура для создания различных типов индексов, включая геометрические.

[К оглавлению](#SQL)

# 54. Опишите разницу между индексами B-дерева и хеш-индексами. В каких случаях предпочтительно использовать каждый из них?

B-Tree — универсальный индекс, поддерживающий быстрый поиск и диапазонные запросы, а также сортировку. Хеш-индекс
оптимизирован для очень быстрого поиска по точному совпадению, но не поддерживает диапазонные запросы и сортировку.
Поэтому в большинстве случаев предпочитают B-Tree, а хеш-индексы применяют, когда нужны только точечные равенства

[К оглавлению](#SQL)

# 55. Как работает индекс с использованием внешних функций (например, lower()) и как это влияет на производительность запросов?

Индексы с внешними функциями, такими как LOWER(), не могут быть использованы напрямую, поскольку функция изменяет данные
и индекс на исходные значения уже не подходит. Для этого в СУБД можно создать индекс с выражением, где результат функции
сохраняется в индексе, что позволяет ускорить выполнение запросов. Однако стоит помнить, что это увеличивает нагрузку на
операции записи, так как индекс должен быть обновлен при каждом изменении данных.

[К оглавлению](#SQL)

# 56. В чем особенности использования индексов в распределенных базах данных?

В распределённых базах данных индексы могут быть локальными на каждом шардe или глобальными, покрывающими все данные.
Локальные индексы проще в поддержании и быстрее обновляются, но при запросах к разным шардам приходится объединять
результаты. Глобальные индексы сложнее поддерживать из-за проблем с консистентностью и производительностью. В
распределённых системах важно проектировать шардирование и ключи таким образом, чтобы минимизировать межузловые запросы
и использовать индексы локально. Из-за сложности поддержки и накладных расходов часто приходится балансировать между
производительностью запросов и стоимостью обновления индексов.

[К оглавлению](#SQL)

# 57. Опишите, что такое хранимая процедура в контексте SQL.

Хранимая процедура — это заранее сохранённый набор SQL-команд, который выполняется на стороне СУБД. Она позволяет
инкапсулировать и повторно использовать бизнес-логику, снижает нагрузку на сеть и повышает производительность, так как
код выполняется ближе к данным и оптимизирован сервером. Хранимые процедуры поддерживают параметры, управляющие
конструкции и помогают централизованно управлять логикой работы с данными

[К оглавлению](#SQL)

# 58. Как можно создать простейшую функцию в SQL?

Функция в SQL — это блок кода, который принимает параметры и возвращает результат. Например, простейшая функция может
выполнять арифметическую операцию, как сложение двух чисел. В разных СУБД синтаксис может немного отличаться, но общая
структура обычно включает определение имени функции, типов параметров и возвращаемого значения. Функции помогают
инкапсулировать логику и повторно использовать её в разных частях приложения

[К оглавлению](#SQL)

# 59. Что такое триггер в базах данных и для чего он используется?

Триггер — это специальная процедура, которая автоматически выполняется в ответ на определённые события в базе данных,
такие как вставка, обновление или удаление данных. Они используются для автоматизации задач, поддержания целостности
данных, ведения журналов и логирования изменений. Триггеры могут работать до или после основного действия, а также могут
заменять его. Однако важно учитывать, что триггеры могут влиять на производительность и делать логику работы с данными
менее очевидной для разработчиков.

[К оглавлению](#SQL)

# 60. Какие преимущества использования хранимых процедур перед кодом на стороне клиента?

Хранимые процедуры дают преимущества по производительности, так как компилируются и выполняются на сервере, снижая
сетевой трафик. Они повышают безопасность, инкапсулируя логику и уменьшая риски SQL-инъекций. Также хранимые процедуры
способствуют повторному использованию и централизованному управлению бизнес-логикой, упрощая поддержку. Дополнительно,
они позволяют контролировать транзакции и уменьшают количество взаимодействий клиента с базой, снижая задержки.

[К оглавлению](#SQL)

# 61. Как передать параметры в SQL функцию и использовать их внутри неё?

В SQL параметры передаются в функцию при её создании, где они становятся доступными как локальные переменные внутри
функции. Это позволяет использовать их в различных операциях, например, для вычислений или фильтрации данных. После
выполнения функции, результат может быть возвращён с помощью ключевого слова RETURN. Например, функция для расчёта
скидки может принимать цену и процент скидки как параметры и возвращать обновлённую цену

[К оглавлению](#SQL)

# 62. Какие типы триггеров существуют и в чем их основные отличия?

Существует три основных типа триггеров по времени срабатывания: BEFORE, который срабатывает до операции и может изменять
данные или прерывать операцию; AFTER, который выполняется после успешного изменения данных, например, для логирования; и
INSTEAD OF, который заменяет операцию, часто используется для работы с представлениями. Также триггеры бывают
строчными (FOR EACH ROW), которые срабатывают на каждую изменённую строку, и операционными (FOR EACH STATEMENT),
выполняющимися один раз за операцию вне зависимости от количества строк. Выбор типа триггера зависит от задачи и
требуемого поведения

[К оглавлению](#SQL)

# 63. Как можно использовать транзакции внутри хранимых процедур для управления изменениями в базе данных?

Транзакции внутри хранимых процедур позволяют управлять несколькими изменениями в базе данных как единым целым. Они
обеспечивают атомарность операций, то есть либо все изменения выполняются, либо при ошибке все откатываются. Это
достигается с помощью команд START TRANSACTION, COMMIT и ROLLBACK. Транзакции позволяют контролировать целостность
данных и избежать их частичного изменения, что критически важно при работе с несколькими таблицами или сложными
бизнес-операциями

[К оглавлению](#SQL)

# 64. Как создать функцию, которая возвращает таблицу в SQL?

Чтобы создать функцию, возвращающую таблицу, в PostgreSQL используют RETURNS TABLE или SETOF RECORD с RETURN QUERY, что
позволяет возвращать набор строк. В SQL Server существуют Table-Valued Functions, которые либо инлайн, либо
многооперационные, возвращающие таблицу через RETURNS TABLE. В MySQL подобную функциональность реализуют с помощью
хранимых процедур, которые выполняют SELECT и возвращают результат клиенту. Такой подход позволяет инкапсулировать
логику выборки и переиспользовать её в запросах

[К оглавлению](#SQL)

# 65. Каким образом можно обработать исключения внутри триггера и каковы лучшие практики для их использования?

Обработка исключений в триггерах реализуется с помощью стандартных конструкций обработки ошибок, таких как EXCEPTION в
PostgreSQL или TRY-CATCH в SQL Server. Внутри блока обработки ошибок можно выполнить логирование, откат изменений или
выбросить исключение дальше. Лучшие практики включают минимизацию логики в триггерах, обязательное логирование ошибок и
предотвращение бесконтрольного подавления исключений, чтобы обеспечить стабильность и прозрачность работы базы данных

[К оглавлению](#SQL)

# 66. Что такое план запроса в контексте SQL?

План запроса — это подробное описание шагов, которые СУБД выполняет для обработки SQL-запроса. Он показывает, какие
таблицы и индексы используются, порядок соединений, фильтрации и другие операции. Анализ плана позволяет понять
производительность запроса и найти возможности для оптимизации. План запроса можно получить с помощью команды EXPLAIN
или аналогичных инструментов в разных СУБД

[К оглавлению](#SQL)

# 67. Как можно просмотреть план запроса в SQL?

Чтобы просмотреть план запроса, в PostgreSQL используют команду EXPLAIN или EXPLAIN ANALYZE, которая показывает, как
СУБД будет или фактически выполняет запрос. В MySQL для этого тоже есть EXPLAIN. В SQL Server можно воспользоваться
кнопкой Estimated Execution Plan в SSMS или командами SET SHOWPLAN_ALL ON. Это позволяет проанализировать эффективность
запроса, понять использование индексов и оптимизировать работу с базой

[К оглавлению](#SQL)

# 68. Почему важно понимать план запроса при оптимизации запросов?

План запроса показывает, как СУБД выполняет запрос, какие индексы используются и где могут быть узкие места по
производительности. Понимание плана позволяет выявлять и устранять проблемные участки, оптимизировать структуру данных и
запросы, что значительно повышает эффективность работы с базой

[К оглавлению](#SQL)

# 69. Какие типы операций можно найти в плане запроса?

Seq Scan (Sequential Scan) — полный последовательный обход всей таблицы, без использования индексов.

Index Scan / Index Seek — поиск данных с использованием индекса, что значительно быстрее, чем полный скан.

Index Only Scan — чтение данных только из индекса без обращения к самой таблице.

Nested Loop Join — вложенное соединение, где для каждой строки из одной таблицы ищут соответствующие строки в другой.

Hash Join — соединение с использованием хэш-таблицы для быстрого сопоставления строк.

Merge Join — соединение отсортированных таблиц с последовательным сравнением.

Sort — операция сортировки данных.

Aggregate — агрегация, например, подсчёт, суммирование, группировка.

Filter — применение условий WHERE или HAVING для отбора строк.

Materialize — сохранение промежуточных результатов для повторного использования.

Bitmap Index Scan / Bitmap Heap Scan — комбинированный подход с использованием битовых карт для эффективного доступа.

[К оглавлению](#SQL)

# 70. Как индексы влияют на план запроса?

Индексы позволяют СУБД значительно сократить объём считываемых данных, что отражается в плане запроса через
использование операций Index Scan вместо полного сканирования. Они помогают выбрать более эффективные методы соединения
и сортировки, а также могут полностью покрывать запрос, исключая обращение к таблице. Поэтому наличие и правильное
использование индексов напрямую влияет на структуру и производительность плана запроса

[К оглавлению](#SQL)

# 71. Какие факторы могут влиять на выбор оптимизатора при составлении плана запроса?

Оптимизатор при построении плана запроса учитывает статистику по объёму и распределению данных, наличие индексов,
условия фильтрации и соединения таблиц, а также параметры конфигурации сервера и стоимости операций. Он анализирует
различные стратегии соединения и доступа, чтобы выбрать самый быстрый и экономичный вариант выполнения запроса

[К оглавлению](#SQL)

# 72. Какие существуют методы оценки стоимости выполнения запроса?

Основной метод оценки стоимости запроса — cost-based optimization, когда оптимизатор рассчитывает числовую стоимость
операций на основе статистики данных и затрат CPU/IO. Он выбирает план с минимальной суммарной стоимостью. Раньше
применялся rule-based подход с фиксированными правилами, но современные СУБД используют преимущественно cost-based
оптимизацию

[К оглавлению](#SQL)

# 73. Как можно влиять на выбор плана запроса без изменения самого запроса?

`Обновление статистики (ANALYZE, UPDATE STATISTICS).`
Оптимизатор опирается на статистику по таблицам и индексам. Чем актуальнее статистика, тем точнее план.

`Создание, удаление или изменение индексов.`
Добавление нужных индексов или удаление неэффективных может кардинально изменить план.

`Использование подсказок (hints).`
Некоторые СУБД позволяют в запросе или на уровне сессии задать подсказки — например, принудительно использовать
конкретный индекс или тип соединения.

`Настройка параметров СУБД.`
Например, ограничение использования памяти для сортировки или настройки параллелизма.

`Изменение порядка таблиц в соединении (JOIN).`
В некоторых СУБД порядок таблиц в запросе влияет на план, но если сам запрос нельзя менять, можно попробовать переписать
представления или настроить планировщик.

`Материализованные представления (Materialized Views)`.
Использование готовых пред - вычисленных результатов вместо прямого запроса к таблицам.

`Кэширование и буферизация.`
Обеспечить, чтобы часто запрашиваемые данные находились в памяти, чтобы ускорить доступ.

[К оглавлению](#SQL)

# 74. Как производится оптимизация запросов на основе плана запроса?

Оптимизация на основе плана запроса начинается с анализа узких мест — например, полного сканирования больших таблиц или
дорогих операций соединения. Затем добавляют индексы, переписывают запросы для упрощения и меньшего количества данных,
используют подсказки при необходимости и обновляют статистику. После изменений обязательно проверяют новый план и
измеряют производительность

[К оглавлению](#SQL)

# 75. Что означает аббревиатура ACID в контексте транзакций в базах данных?

ACID — это набор принципов, гарантирующих корректность работы транзакций. Atomicity (Атомарность) означает, что
транзакция либо выполняется полностью, либо не выполняется вообще. Consistency (Согласованность) гарантирует, что данные
после транзакции будут в валидном состоянии. Isolation (Изолированность) обеспечивает изолированность транзакций, а
Durability (Долговечность) гарантирует, что изменения, сделанные транзакцией, сохранятся даже после сбоя

[К оглавлению](#SQL)

# 76. Что такое транзакция в контексте баз данных?

Транзакция — это набор операций с базой данных, который выполняется как одна атомарная единица. Если все операции
проходят успешно, изменения фиксируются, иначе — откатываются. Это обеспечивает целостность данных и предотвращает
частичные или неконсистентные изменения

[К оглавлению](#SQL)

# 77. Какие основные уровни изолированности существуют?

- `Read Uncommitted (Чтение незафиксированных данных)`

Описание: На этом уровне одна транзакция может читать данные, изменённые другой транзакцией, даже если та транзакция ещё
не была завершена (не зафиксирована).

Проблемы: Возможны грязные чтения (dirty reads), когда транзакция может читать данные, которые потом будут откатаны, что
приведёт к неконсистентности.

Используется: Когда производительность важнее, чем точность данных, и возможны определённые погрешности в процессе
работы.

- `Read Committed (Чтение только зафиксированных данных)`

Описание: Транзакция может читать только те данные, которые были зафиксированы другими транзакциями. Это исключает
грязные чтения, но всё ещё может привести к проблемам.

Проблемы: Возможны неповторяющиеся чтения (non-repeatable reads), когда данные, считанные в одном месте, могут быть
изменены другой транзакцией в ходе той же транзакции.

Используется: Наиболее часто применяемый уровень изолированности в большинстве СУБД, так как он предлагает разумный
баланс между точностью данных и производительностью.

- `Repeatable Read (Повторяемое чтение)`

Описание: Транзакция гарантирует, что все данные, прочитанные ею, останутся неизменными до завершения транзакции.
Исключаются неповторяющиеся чтения.

Проблемы: Возможны фантомные чтения (phantom reads), когда другая транзакция может вставить новые строки, подходящие под
условия запроса, в процессе выполнения текущей транзакции.

Используется: Когда требуется высокий уровень консистентности данных, но без необходимости полной блокировки таблиц.

- `Serializable (Сериализуемость)`

Описание: Этот уровень обеспечивает наивысший уровень изолированности. Транзакции выполняются так, как если бы они
выполнялись поочередно, одна за другой, исключая возможность параллельного доступа к данным.

Проблемы: Это может сильно повлиять на производительность, так как транзакции блокируют доступ к данным для других
транзакций, пока они не завершены.

Используется: Когда требуется абсолютная консистентность данных, например, при обработке финансовых операций, где
абсолютно важна корректность.

[К оглавлению](#SQL)

# 78. Каковы основные различия между уровнями изолированности транзакций READ UNCOMMITTED и READ COMMITTED?

Основное различие между уровнями изолированности READ UNCOMMITTED и READ COMMITTED заключается в том, что READ
UNCOMMITTED позволяет читать незафиксированные данные, что может привести к грязным чтениям, а READ COMMITTED позволяет
читать только данные, которые уже были зафиксированы, что исключает грязные чтения, но сохраняет возможность
неповторяющихся чтений. READ COMMITTED предлагает лучший баланс между консистентностью и производительностью

[К оглавлению](#SQL)

# 79. Как SERIALIZABLE уровень изолированности влияет на выполнение транзакций?

Уровень изолированности SERIALIZABLE обеспечивает максимальную консистентность данных, гарантируя, что транзакции
выполняются последовательно, как если бы они были выполнены по очереди. Этот уровень предотвращает все виды аномалий,
включая грязные и неповторяющиеся чтения, а также фантомные чтения. Однако, из-за блокировок, его использование может
существенно повлиять на производительность, что делает его не идеальным для систем с высоким уровнем параллельных
операций

[К оглавлению](#SQL)

# 80. Какие стратегии и подходы используются для оптимизации производительности при работе с транзакциями?

Для оптимизации производительности при работе с транзакциями важно минимизировать время их выполнения, использовать
подходящий уровень изолированности (например, READ COMMITTED вместо SERIALIZABLE), избегать длительных блокировок, а
также использовать пакетные операции и индексы. Также стоит тщательно оптимизировать запросы внутри транзакций и
настроить СУБД для работы с высокими нагрузками. В некоторых случаях можно применить параллельное выполнение транзакций
или snapshot isolation, чтобы повысить эффективность работы системы

[К оглавлению](#SQL)

# 81. Как можно реализовать механизм оптимистической блокировки в контексте управления транзакциями?

Оптимистическая блокировка реализуется через дополнительное поле, например, version или timestamp, которое обновляется
при каждом изменении записи. Когда транзакция пытается обновить запись, она сравнивает сохранённую версию с текущей.
Если они не совпадают, это означает конфликт, и транзакция отклоняется. Это эффективно при низкой вероятности
конфликтов, особенно в распределённых и высоконагруженных системах. В JPA используется аннотация @Version, которая
упрощает реализацию этой механики

[К оглавлению](#SQL)

# 82. Какие стратегии и подходы используются для оптимизации производительности при работе с транзакциями в распределенных системах?

В распределённых системах, чтобы оптимизировать производительность транзакций, я избегаю глобальных блокирующих
транзакций и использую подходы вроде Saga, CQRS и eventual consistency. Предпочитаю локальные транзакции с компенсацией,
минимальный уровень изоляции, кэширование и шардинг. Также важно обеспечить идемпотентность операций и управлять
отказами с помощью таймаутов, откатов и ретраев. Если проект требует согласованности, применяю Snapshot Isolation или
BASE-подход, в зависимости от бизнес-требований

[К оглавлению](#SQL)

# 83. Как можно обеспечить атомарность транзакций, выполняющихся параллельно, без ухудшения производительности?

- `Использование многоверсионного контроля параллелизма (MVCC)`

Описание: Вместо блокировки строк каждая транзакция видит "снимок" (snapshot) данных на момент начала. Это позволяет
читать без блокировок.

Где используется: PostgreSQL, Oracle, MySQL (InnoDB).

Плюсы: Высокая производительность чтения. Позволяет параллельные SELECT и UPDATE.

Минус: Требует очистки старых версий (VACUUM в PostgreSQL).

- `Атомарность на уровне команд (statement-level atomicity)`

Описание: Даже отдельные SQL-команды, такие как UPDATE, выполняются атомарно — либо полностью, либо никак.

Практика: Делай меньше, но безопасно — лучше 1 атомарная команда, чем множество мелких, которые могут провалиться по
пути.

- `Индемпотентность и повторные попытки (Retry + Idempotency)`

Описание: Если транзакция провалилась из-за конкуренции (например, version conflict), можно её повторить.

Что делать: Добавляй version поле (оптимистическая блокировка). Обрабатывай OptimisticLockException с повтором
транзакции.

- `Локальные короткоживущие транзакции`

Описание: Держи транзакции как можно короче и локализуй изменения.

Практика: Не держи транзакции через сеть, UI, Kafka listener и т.п. Не делай sleep или долгих вычислений внутри
транзакции.

- `Выбор минимального уровня изоляции`

Описание: Чем выше уровень изоляции, тем больше блокировок и выше задержки

Рекомендация: READ COMMITTED — хорошая производительность и безопасный минимум. Используй SERIALIZABLE только там, где
это критично

Чтобы обеспечить атомарность параллельных транзакций без потери производительности, я применяю MVCC, оптимистическую
блокировку с версионностью, и избегаю долгоживущих транзакций. Я стараюсь локализовать изменения и использовать
минимальный уровень изоляции, например Read Committed. Также важно делать транзакции короткими и использовать атомарные
SQL-операции. При конфликте применяю retry-механику или компенсирующие действия — особенно в распределённых системах

[К оглавлению](#SQL)

# 84. Что такое репликация в контексте реляционных баз данных?

Репликация — это механизм синхронизации данных между несколькими экземплярами базы данных. Она обеспечивает
отказоустойчивость, масштабируемость чтения и доступность. Бывает master-slave, multi-master, синхронная и асинхронная.
В зависимости от требований к консистентности и задержкам я выбираю подходящую стратегию — например, асинхронную
репликацию для повышения производительности, или синхронную для критичных данных

[К оглавлению](#SQL)

# 85. Почему шардирование может быть полезным для больших баз данных?

Шардирование — это метод горизонтального масштабирования базы данных, который помогает справиться с большими объёмами
данных. Оно улучшает производительность за счёт распределения данных по разным серверам, обеспечивает отказоустойчивость
и позволяет легко масштабировать систему. Основные типы шардирования — по диапазону, хешированию и ключу. Однако,
шардирование также добавляет сложности управления, особенно при выполнении JOIN операций между разными шардовыми
частями. Важно тщательно планировать архитектуру, чтобы минимизировать риски и упростить работу с системой

[К оглавлению](#SQL)

# 86. Каковы основные цели партиционирования данных?

Партиционирование используется для повышения производительности и управляемости больших таблиц. Оно позволяет ограничить
сканирование только нужной частью таблицы (partition pruning), упрощает удаление и архивацию данных, улучшает
параллелизм и экономит ресурсы за счёт локальных индексов. Я предпочитаю использовать партиционирование по дате для
журналов или операций, и по спискам — для распределения по регионам. Главное — правильно выбрать ключ разбиения, чтобы
избежать горячих партиций (это когда одна партиция перегружена, остальные простаивают)

[К оглавлению](#SQL)

# 87. Какие существуют типы репликации в реляционных базах данных и в чем их различия?

В реляционных базах данных существует несколько типов репликации: синхронная, асинхронная, полусинхронная, а также
логическая и физическая. Синхронная репликация обеспечивает максимальную консистентность, но замедляет запись.
Асинхронная — быстрая, но с риском потери данных при сбоях. Также различают одностороннюю и многостороннюю репликацию:
первая масштабирует чтение, вторая требует разрешения конфликтов. Я обычно выбираю тип репликации, исходя из требований
к доступности, консистентности и производительности.

[К оглавлению](#SQL)

# 88. Какие проблемы могут возникнуть при шардировании базы данных и как их можно решить?

Шардирование помогает масштабировать базы данных горизонтально, но влечёт за собой целый ряд сложностей. Основные
проблемы — это выбор правильного ключа шардирования, кросс-шардовые операции, миграции, и потеря поддержки глобальных
транзакций. Чтобы их избежать, я использую хеш-функции, динамическое или гибридное шардирование, отказоустойчивый
middleware, репликацию справочников и паттерны вроде саг. Важно также автоматизировать бэкапы и мониторинг, чтобы не
утонуть в операционке

[К оглавлению](#SQL)

# 89. Какие существуют стратегии партиционирования таблиц в реляционных базах данных?

Существует несколько основных стратегий партиционирования таблиц: диапазонное, где данные разбиваются по диапазонам
значений, например, по дате; списковое, когда данные разделяются по конкретным значениям, например, по регионам;
хеширование, обеспечивающее равномерное распределение данных; и комбинированное, где используются два и более метода
вместе. Выбор зависит от характера данных и нагрузки. Партиционирование улучшает производительность, позволяет
эффективно управлять большими таблицами и упрощает администрирование

[К оглавлению](#SQL)

# 90. Опишите процесс настройки мастер-слейв репликации в реляционной базе данных.

Мастер-слейв репликация — это процесс, где мастер записывает изменения в журнал транзакций, а слейвы асинхронно получают
и применяют эти изменения, обеспечивая масштабирование чтения и отказоустойчивость. Настройка включает: активацию
логирования на мастере, создание резервной копии базы, развертывание её на слейве, настройку подключения слейва к
мастеру и запуск репликации. Очень важно мониторить задержки репликации и обеспечить безопасность каналов связи

[К оглавлению](#SQL)

# 91. В чем заключается проблема горячих точек при шардировании и какие подходы могут помочь в ее решении?

Проблема горячих точек при шардировании — это когда часть шардов получает несоразмерно высокую нагрузку, что приводит к
узким местам и снижению производительности всей системы. Для решения применяют равномерное хеширование, динамическое
перераспределение данных (ре-шардирование), кэширование горячих данных, а также могут использовать составные ключи и
балансировку на уровне приложения. Важно, чтобы данные и нагрузка равномерно распределялись между всеми шардовыми узлами

[К оглавлению](#SQL)

# 92. Как партиционирование данных может влиять на производительность запросов в реляционных базах данных и при каких условиях это эффект наиболее заметен?

Партиционирование помогает повысить производительность за счёт ограничения объёма данных, обрабатываемых запросом, через
механизм partition pruning — СУБД обращается только к нужным партициям, а не к всей таблице. Кроме того,
партиционирование позволяет распараллеливать выполнение запросов и ускоряет операции модификации данных. Эффект особенно
заметен при больших объёмах данных и запросах с фильтрацией по ключу партиционирования, например, по дате или категории

[К оглавлению](#SQL)

# 93. Что такое SQL инъекция?

SQL инъекция — это уязвимость, когда злоумышленник вставляет в пользовательский ввод фрагменты SQL-кода, который потом
выполняется в базе, позволяя ему получить или изменить данные незаконным образом. Основная защита — использование
параметризованных запросов, которые отделяют код от данных, а также валидация и экранирование входных данных

[К оглавлению](#SQL)

# 94. Какие могут быть последствия использования SQL инъекций?

SQL-инъекции могут привести к утечке и потере данных, обходу авторизации, модификации информации и даже выполнению
произвольного кода на сервере. Это критическая уязвимость, которая ставит под угрозу безопасность всей системы и
репутацию компании

[К оглавлению](#SQL)

# 95. В каких случаях приложение может быть уязвимо к SQL инъекциям?

Приложение уязвимо к SQL-инъекциям, когда пользовательские данные напрямую подставляются в SQL-запрос без параметризации
и валидации — обычно это динамическая конкатенация строк для построения запросов. Чтобы избежать уязвимости, необходимо
использовать параметризованные запросы (PreparedStatement), тщательно проверять и фильтровать входные данные, а также
ограничивать права доступа на уровне базы

[К оглавлению](#SQL)

# 96. Как можно предотвратить SQL инъекции при использовании динамически формируемых запросов?

При динамическом формировании запросов ключевая защита — параметризация запросов через Prepared Statements, которая
отделяет данные от кода SQL. Дополнительно нужно валидировать и фильтровать пользовательский ввод, использовать белые
списки для контролируемых значений, а также ограничивать права доступа в базе. Это гарантирует, что данные не будут
интерпретированы как часть SQL-кода

[К оглавлению](#SQL)

# 97. Какие методы предотвращения SQL инъекций существуют в Java?

В Java ключевой метод защиты от SQL-инъекций — использование PreparedStatement, который позволяет безопасно передавать
параметры без конкатенации строк. Также важно применять ORM, которые автоматически параметризуют запросы, валидировать
ввод пользователя и ограничивать права доступа в базе. Это комплексный подход, который сводит к минимуму риск инъекций

```java
String sql = "SELECT * FROM employees WHERE id = ?";
PreparedStatement ps = connection.prepareStatement(sql);
ps.setInt(1, employeeId);
ResultSet rs = ps.executeQuery();

```

[К оглавлению](#SQL)

# 98. Как работает PreparedStatement в Java в контексте предотвращения SQL инъекций?

- Когда мы используем PreparedStatement, SQL-запрос и параметры передаются отдельно. Это значит, что даже если данные,
  передаваемые в запрос, содержат вредоносный код, он будет восприниматься как простое значение, а не как часть
  SQL-запроса. Таким образом, нет риска того, что пользовательский ввод станет частью SQL-оператора.
- При создании PreparedStatement запрос компилируется один раз, и база данных заранее знает структуру запроса.
  Параметры (например, значения переменных) подставляются в места, обозначенные знаками вопроса `?`. Это делает запрос
  безопасным, потому что нет возможности изменить саму структуру SQL.
- Когда параметры передаются в PreparedStatement, они экранируются автоматически, что предотвращает возможность
  инъекций, где пользователь пытается вставить произвольный SQL-код.

```java
String sql = "SELECT * FROM employees WHERE username = ? AND password = ?";
PreparedStatement preparedStatement = connection.prepareStatement(sql);

// Устанавливаем значения для параметров
preparedStatement.setString(1, username);
preparedStatement.setString(2, password);

// Выполняем запрос
ResultSet resultSet = preparedStatement.executeQuery();
```

[К оглавлению](#SQL)

# 99. Какие существуют специфичные техники обнаружения SQL инъекций при проведении тестирования на проникновение?

- `Ввод специальных символов и SQL-операторов`
  Классическая техника — попытаться ввести фрагмент SQL-запроса вручную:

````
' OR '1'='1
' UNION SELECT null, version(), user() --
````
Если приложение не экранирует ввод, можно вызвать ошибку или получить неожиданный результат.

- `Ошибочная (error-based) инъекция`

Ввод специальных конструкций, которые вызывают SQL-ошибку. Например:

`' AND 1=CONVERT(int, (SELECT @@version))--`

Если в ответе появляется сообщение об ошибке БД — это сигнал, что запрос был скомпрометирован.

- `Слепая SQL-инъекция (blind SQL injection)`

Применяется, если приложение не выводит ошибки. Тестировщик проверяет поведение системы на истинные/ложные условия:
````
' AND 1=1 -- (ожидается успех)
' AND 1=2 -- (ожидается провал)
````

- `Time-based Blind SQL Injection`

Применяется задержка выполнения (например, SLEEP(5) в MySQL) — это позволяет понять, исполняется ли SQL:

`' OR IF(1=1, SLEEP(5), 0)--`

Если приложение "зависает", значит SQL выполнился — есть инъекция.

- `UNION-инъекция`

Проверяется, можно ли объединить результаты двух запросов:

`' UNION SELECT null, version()--`

- `Анализ поведения при изменении запроса`

Подставляются нестандартные или неожиданные значения, чтобы изменить структуру запроса и отследить поведение

- `Использование автоматических инструментов`

sqlmap — один из самых мощных инструментов для автоматизированного поиска и эксплуатации SQL-инъекций.

Burp Suite — прокси и сканер, позволяет анализировать запросы/ответы и обнаруживать уязвимости.

ZAP (OWASP Zed Attack Proxy) — инструмент с открытым исходным кодом для динамического анализа безопасности приложений.

[К оглавлению](#SQL)

# 100. Как можно использовать Content Security Policy для защиты от SQL инъекций?

Content Security Policy — это механизм защиты на стороне клиента, основной целью которого является предотвращение
XSS-атак. Хотя CSP напрямую не защищает от SQL-инъекций, он может косвенно способствовать защите, блокируя вредоносные
скрипты, которые могли бы инициировать SQL-инъекции через XSS. Для защиты от SQL-инъекций на сервере я использую
PreparedStatement, ORM и строгую валидацию

[К оглавлению](#SQL)

# 101. Какие существуют методы автоматизации обнаружения уязвимостей к SQL инъекциям в больших системах?

Для автоматического обнаружения SQL-инъекций в больших системах я применяю как статический, так и динамический анализ.
SAST-инструменты, такие как SonarQube или Fortify, позволяют выявить потенциальные уязвимости на уровне исходного кода.
DAST-инструменты, такие как ZAP или Burp Suite, работают с развернутым приложением, имитируя атаки и анализируя ответы.
Я интегрирую такие проверки в CI/CD пайплайны, чтобы безопасность была частью DevSecOps. Также использую SQLMap и
fuzz-тестирование для углубленной проверки

[К оглавлению](#SQL)

# 102. Что такое SQL?

SQL — это декларативный язык для управления данными в реляционных базах данных. Он охватывает операции на уровне
данных (DML), структуры (DDL), транзакций (TCL) и управления доступом (DCL). SQL позволяет писать как простые запросы
SELECT, так и сложные подзапросы, объединения (JOIN), использовать оконные функции и агрегатные вычисления. Это
фундамент любой работы с базами данных

[К оглавлению](#SQL)

# 103. Какие операции можно выполнять с помощью DML?

DML — это набор SQL-команд, который используется для управления данными в таблицах. Он включает в себя SELECT для
извлечения, INSERT для добавления, UPDATE для изменения и DELETE для удаления записей. Эти операции, как правило,
выполняются в рамках транзакций, что позволяет управлять целостностью данных.

[К оглавлению](#SQL)

# 104. Чем отличается DDL от DML?

DDL и DML — это подмножества SQL с разными задачами. DDL отвечает за определение структуры базы — например, создание
таблиц и индексов через CREATE, ALTER, DROP. Эти операции фиксируются автоматически. А DML используется для работы с
содержимым таблиц — SELECT, INSERT, UPDATE, DELETE и выполняется в рамках транзакций. Я чётко разделяю эти роли при
проектировании схем и написании логики доступа к данным

[К оглавлению](#SQL)

# 105. Как можно изменить структуру таблицы, используя DDL?

Чтобы изменить структуру таблицы, используем команды DDL, такие как ALTER TABLE, которые позволяют добавлять, удалять и
изменять столбцы или ограничения. Для удаления таблицы используется команда DROP TABLE, а для очистки данных — TRUNCATE
TABLE. Все эти операции касаются схемы и не изменяют данные напрямую, но при этом позволяют гибко адаптировать структуру
базы данных к меняющимся требованиям

[К оглавлению](#SQL)

# 106. Приведите пример команды DCL.

DCL — это язык управления доступом в SQL. С его помощью я могу задавать, кому и какие операции разрешены в базе.
Например, через GRANT можно выдать пользователю доступ к чтению и вставке в таблицу, а через REVOKE — отобрать доступ.
Это важно для соблюдения принципов безопасности и разграничения прав

[К оглавлению](#SQL)

# 107. Какие транзакции поддерживает TCL и как их использовать?

TCL позволяет управлять транзакциями в SQL. Я использую BEGIN или START TRANSACTION, чтобы начать транзакцию, COMMIT,
чтобы зафиксировать изменения, и ROLLBACK, чтобы их откатить. При сложной логике можно использовать SAVEPOINT, чтобы
частично откатить транзакцию до определённой точки. Это особенно полезно для обеспечения ACID-свойств и безопасной
обработки ошибок при работе с БД

[К оглавлению](#SQL)

# 108. Какие стратегии оптимизации запросов вы знаете?

Я применяю несколько стратегий для оптимизации SQL-запросов. Это использование индексов, отказ от SELECT *, замена IN на
EXISTS, профилирование запросов с помощью EXPLAIN, а также продуманное использование денормализации, материализованных
представлений и пагинации без OFFSET. Всегда анализирую план выполнения, особенно на больших объемах данных. Такой
подход позволяет добиться высокой производительности и масштабируемости базы данных

[К оглавлению](#SQL)

# 109. Как реализовать версионирование данных в реляционной базе данных?

Версионирование позволяет хранить все изменения записей, а не просто перезаписывать их. Это как Git, только для строк в
таблице. Вместо UPDATE по месту, мы либо сохраняем историю изменений, либо храним все версии записи.

#### Подходы к версионированию

- `Таблица-история (Audit Table или History Table)`

Для каждой основной таблицы создаётся таблица истории, например: users → users_history.

```java
CREATE TABLE users_history (
  id BIGINT,
  name TEXT,
  email TEXT,
  version INT,
  changed_at TIMESTAMP,
  changed_by TEXT,
  operation_type TEXT -- 'INSERT', 'UPDATE', 'DELETE'
);
```

```java
Триггеры или приложение записывают 
старое состояние при каждом изменении:

CREATE TRIGGER trg_users_update
BEFORE UPDATE ON users
FOR EACH ROW
        BEGIN
INSERT INTO users_history
VALUES (OLD.id, OLD.name, OLD.email, OLD.version, NOW(), 'system', 'UPDATE');
END;
```

- `Модель с полем version и is_current`

В одной таблице хранятся все версии записи. Каждая новая версия — новая строка.

```java
CREATE TABLE documents (
  id UUID,
  version INT,
  title TEXT,
  content TEXT,
  is_current BOOLEAN,
  created_at TIMESTAMP
);
```

Пример:

version = 1, is_current = false

version = 2, is_current = true

Перед обновлением текущей версии, ты:

Помечаешь старую как is_current = false.

Вставляешь новую с version + 1.

- `Временные интервалы (SCD Type 2 — Slowly Changing Dimension)`

Поля: valid_from, valid_to

```java
CREATE TABLE employee_versions (
  employee_id INT,
  name TEXT,
  salary NUMERIC,
  valid_from DATE,
  valid_to DATE
);
```

Когда данные обновляются: Старой записи ставим valid_to = CURRENT_DATE. Вставляем новую с valid_from = CURRENT_DATE,
valid_to = NULL.

- `PostgreSQL 15+: system versioned tables (SQL:2011)`

Если ты используешь современные СУБД, например PostgreSQL 15+, можно делать это декларативно с системным временным
отслеживанием (SYSTEM VERSIONING), как в SQL:2011.

#### Что учитывать при выборе подхода

- Нужно хранить только историю -> Историческая таблица 
- Нужен доступ к текущей и прошлым версиям -> Версии в основной таблице 
- Нужен аудит + время жизни -> SCD Type 2 или временные интервалы 
- Хочешь автоматизации -> Используй триггеры или логирование на уровне СУБД

[К оглавлению](#SQL)

# 110. Приведите пример использования всех четырёх типов команд (DDL, DML, DCL, TCL) в рамках одного бизнес-ценария.

В одном бизнес-сценарии легко можно применить все четыре типа SQL-команд. Например, при разработке HR-системы: сначала
создаётся таблица сотрудников с помощью DDL, затем с помощью DML мы добавляем или обновляем записи. DCL используется,
чтобы выдать права HR-менеджеру только на чтение и изменение зарплат, а изменения, касающиеся начисления бонусов,
оборачиваются в транзакции с помощью TCL, чтобы обеспечить атомарность. Такой подход отражает реальную работу с БД в
продакшене

```java
DDL (Data Definition Language)
Создание таблиц и схемы базы данных.


CREATE TABLE employees (
        id SERIAL PRIMARY KEY,
        name VARCHAR(100),
department VARCHAR(50),
salary NUMERIC(10,2),
hire_date DATE
);


Применяется: один раз при инициализации схемы или при миграциях.
CREATE, ALTER, DROP, TRUNCATE
```

```java
DML (Data Manipulation Language)
Работа с данными: добавление, изменение, удаление


INSERT INTO employees (name, department, salary, hire_date)
VALUES ('Alice Johnson', 'HR', 5500, '2022-01-10');

UPDATE employees SET salary = salary + 500 WHERE department = 'HR';

DELETE FROM employees WHERE name = 'Test User';


Применяется: при любом бизнес-действии — найм, повышение зарплаты, увольнение
INSERT, UPDATE, DELETE, SELECT
```

```java
DCL (Data Control Language)
Управление доступом к данным


GRANT SELECT, INSERT, UPDATE ON employees TO hr_user;
REVOKE DELETE ON employees FROM hr_user;


Применяется: для выдачи или отзыва прав конкретным пользователям или ролям.
GRANT, REVOKE
```

```java
TCL (Transaction Control Language)
Управление транзакциями


BEGIN;
UPDATE employees SET salary = salary + 1000 WHERE department = 'Engineering';
INSERT INTO salary_audit (employee_id, change_date, change_amount)
VALUES (101, CURRENT_DATE, 1000);
COMMIT;


Применяется: при необходимости атомарности —
все изменения должны быть успешными или не выполниться вовсе
BEGIN, COMMIT, ROLLBACK, SAVEPOINT
```

[К оглавлению](#SQL)