## WebService

[1. Что такое SOAP и REST в контексте веб-сервисов?](#1-что-такое-soap-и-rest-в-контексте-веб-сервисов)

[2. В каких случаях предпочтительнее использовать SOAP, а в каких — REST?](#2-в-каких-случаях-предпочтительнее-использовать-soap-а-в-каких--rest)

[3. В чем основное различие между SOAP и REST?](#3-в-чем-основное-различие-между-soap-и-rest)

[4. Какие форматы данных обычно используются в REST и SOAP сервисах?](#4-какие-форматы-данных-обычно-используются-в-rest-и-soap-сервисах)

[5. Каковы основные требования к безопасности для SOAP и REST сервисов?](#5-каковы-основные-требования-к-безопасности-для-soap-и-rest-сервисов)

[6. Как происходит обмен сообщениями между клиентом и сервером в REST и в SOAP?](#6-как-происходит-обмен-сообщениями-между-клиентом-и-сервером-в-rest-и-в-soap)

[7. Какие существуют спецификации безопасности для SOAP и как они реализуются?](#7-какие-существуют-спецификации-безопасности-для-soap-и-как-они-реализуются)

[8. Какие существуют методы оптимизации производительности REST сервисов?](#8-какие-существуют-методы-оптимизации-производительности-rest-сервисов)

[9. В чем состоят сложности миграции с SOAP на REST и как их можно преодолеть?](#9-в-чем-состоят-сложности-миграции-с-soap-на-rest-и-как-их-можно-преодолеть)

[10. Что такое SOAP в контексте веб-сервисов?](#10-что-такое-soap-в-контексте-веб-сервисов)

[11. Какие основные преимущества использования SOAP перед REST?](#11-какие-основные-преимущества-использования-soap-перед-rest)

[12. Какие стандарты используются в SOAP для обмена сообщениями?](#12-какие-стандарты-используются-в-soap-для-обмена-сообщениями)

[13. Какие инструменты используются для создания SOAP веб-сервисов в Java?](#13-какие-инструменты-используются-для-создания-soap-веб-сервисов-в-java)

[14. Каковы основные этапы создания SOAP веб-сервиса?](#14-каковы-основные-этапы-создания-soap-веб-сервиса)

[15. Каким образом осуществляется обмен данными между клиентом и сервером в SOAP веб-сервисах?](#15-каким-образом-осуществляется-обмен-данными-между-клиентом-и-сервером-в-soap-веб-сервисах)

[16. Как реализовать безопасность в SOAP веб-сервисах с использованием WS-Security?](#16-как-реализовать-безопасность-в-soap-веб-сервисах-с-использованием-ws-security)

[17. Какие подходы используются для оптимизации производительности SOAP веб-сервисов?](#17-какие-подходы-используются-для-оптимизации-производительности-soap-веб-сервисов)

[18. Как можно реализовать версионирование SOAP веб-сервисов?](#18-как-можно-реализовать-версионирование-soap-веб-сервисов)

[19. Что такое REST?](#19-что-такое-rest)

[20. Перечислите какие-либо коды ответов HTTP и их значения.
](#20-перечислите-какие-либо-коды-ответов-http-и-их-значения)

[21. Какие HTTP методы считаются идемпотентными?](#21-какие-http-методы-считаются-идемпотентными)

[22. Как в контексте REST применяются принципы безопасности и идемпотентности?
](#22-как-в-контексте-rest-применяются-принципы-безопасности-и-идемпотентности)

[23. Каково значение и использование кода ответа HTTP 204?
](#23-каково-значение-и-использование-кода-ответа-http-204)

[24. В чем разница между методами PUT и PATCH в контексте REST?](#24-в-чем-разница-между-методами-put-и-patch-в-контексте-rest)

[25. Как REST использует принципы единообразия интерфейса и беспостредственного управления ресурсами?
](#25-как-rest-использует-принципы-единообразия-интерфейса-и-беспостредственного-управления-ресурсами)

[26. Какие существуют подходы к обработке версионирования в RESTful API?
](#26-какие-существуют-подходы-к-обработке-версионирования-в-restful-api)

[27. Опишите, как в RESTful веб-сервисах реализуется кеширование и его влияние на производительность.
](#27-опишите-как-в-restful-веб-сервисах-реализуется-кеширование-и-его-влияние-на-производительность)

[28. Объясните, что такое HATEOAS?](#28-объясните-что-такое-hateoas)

[29. Что такое протокол HTTP?
](#29-что-такое-протокол-http)

[30. Каковы основные методы запросов HTTP?
](#30-каковы-основные-методы-запросов-http)

[31. Что такое статус-код в ответе HTTP?](#31-что-такое-статус-код-в-ответе-http)

[32. Как работает механизм перенаправления (редиректа) в HTTP?
](#32-как-работает-механизм-перенаправления-редиректа-в-http)

[33. В чем разница между HTTP и HTTPS?
](#33-в-чем-разница-между-http-и-https)

[34. Какие существуют типы содержимого (Content-Type) в HTTP?](#34-какие-существуют-типы-содержимого-content-type-в-http)

[35. Как реализован механизм сжатия данных в HTTP и какие алгоритмы сжатия обычно используются?
](#35-как-реализован-механизм-сжатия-данных-в-http-и-какие-алгоритмы-сжатия-обычно-используются)

[36. Какие механизмы безопасности используются в HTTPS?
](#36-какие-механизмы-безопасности-используются-в-https)

[37. Какие нововведения были введены в HTTP/2 по сравнению с HTTP/1.1?](#37-какие-нововведения-были-введены-в-http2-по-сравнению-с-http11)


# 1. Что такое SOAP и REST в контексте веб-сервисов?

SOAP — это протокол обмена сообщениями, основанный на XML. Он строго структурирован, использует WSDL для описания, поддерживает надёжность, безопасность и транзакции через WS-* стандарты.

REST — это архитектурный стиль, который использует HTTP-методы и ресурсы. Он проще, легче и чаще применяется в микросервисной архитектуре. REST обычно использует JSON и гораздо менее «тяжёлый», чем SOAP.

[К оглавлению](#WebService)

# 2. В каких случаях предпочтительнее использовать SOAP, а в каких — REST?

Если нужен строгий контракт, расширенные возможности безопасности, надёжная доставка сообщений — тогда лучше использовать SOAP. Например, при интеграции с банковскими или государственными системами, где важно соответствовать WS-* стандартам.

А если нужен лёгкий, гибкий и быстрый API для микросервисов, веба или мобильного приложения — в таких случаях предпочтительнее использовать REST, так как он проще, масштабируем и быстрее в обработке.

[К оглавлению](#WebService)

# 3. В чем основное различие между SOAP и REST?

Основное различие в том, что SOAP — это протокол с чёткими правилами, который работает только с XML, использует WSDL для описания сервиса и обеспечивает расширенные возможности — например, WS-Security, транзакции и надёжную доставку сообщений.

REST — это архитектурный стиль, который опирается на HTTP. Он легче, быстрее, использует ресурсы и HTTP-методы. Обычно передаёт данные в JSON и не требует строгого контракта. REST проще в разработке и чаще применяется в микросервисной архитектуре и фронтенд-бэкенд взаимодействии.

[К оглавлению](#WebService)

# 4. Какие форматы данных обычно используются в REST и SOAP сервисах?

В SOAP-сервисах всегда используется XML, так как это требование самого протокола. Каждое сообщение оформляется как SOAP Envelope с определённой структурой.

В REST-сервисах формат данных гибкий. Чаще всего используется JSON, так как он компактный, легко читается и обрабатывается. Также возможны другие форматы — XML, YAML, plain text или Protobuf — в зависимости от настроек и соглашений между клиентом и сервером. Формат определяется через HTTP-заголовки Content-Type и Accept.

[К оглавлению](#WebService)

# 5. Каковы основные требования к безопасности для SOAP и REST сервисов?

SOAP использует WS-Security, которая работает на уровне сообщения. Это позволяет шифровать и подписывать XML, передавать токены, сертификаты, а также защищаться от replay-атак через таймстемпы. Такой подход удобен, если нужно обеспечить безопасность независимо от транспорта.

В REST безопасность реализуется на уровне транспорта — через HTTPS, аутентификацию с помощью JWT или OAuth2, контроль доступа с помощью CORS, защита от CSRF, rate limiting и другие практики.

REST проще в использовании, но требует осознанной настройки всех уровней защиты. SOAP же предлагает более комплексную и стандартизированную модель безопасности, что делает его предпочтительным в строго регулируемых системах.

[К оглавлению](#WebService)

# 6. Как происходит обмен сообщениями между клиентом и сервером в REST и в SOAP?

В REST обмен сообщениями происходит через стандартные HTTP-запросы. Клиент обращается к ресурсу с помощью методов GET, POST, PUT, DELETE, передаёт данные в теле запроса, как правило в JSON-формате. Ответ также приходит в формате JSON, с соответствующим HTTP-статусом.

В SOAP клиент всегда отправляет POST-запрос, где в теле содержится строго структурированный XML-документ — SOAP Envelope. Все данные и инструкции (операции, параметры, авторизация и т.п.) передаются внутри XML. Ответ также приходит в виде SOAP XML, включая успешные данные или ошибку в формате <soap:Fault>.

REST ближе к вебу и проще, SOAP — более формализованный, используется там, где важно описание операций через контракты (WSDL).

[К оглавлению](#WebService)

# 7. Какие существуют спецификации безопасности для SOAP и как они реализуются?

| Спецификация              | Назначение                                                                                 |
| ------------------------- | ------------------------------------------------------------------------------------------ |
| **WS-Security**           | Базовая безопасность сообщений (подпись, шифрование, токены)                               |
| **WS-Policy**             | Декларация требований по безопасности (например, «все сообщения должны быть подписаны»)    |
| **WS-SecurityPolicy**     | Конкретизация политики безопасности через XML                                              |
| **WS-Trust**              | Расширение для управления **токенами безопасности**, работа с STS (Security Token Service) |
| **WS-SecureConversation** | Создание защищённого сеанса между клиентом и сервером (аналог сессии)                      |
| **WS-Federation**         | Позволяет строить **федеративную аутентификацию** (SAML, ADFS, SSO между системами)        |
| **WS-ReliableMessaging**  | Гарантированная доставка сообщений — даже при сбоях связи                                  |


В SOAP используются стандарты WS-*, главным образом — WS-Security. Он позволяет добавлять в SOAP-сообщения подписи, шифрование и токены безопасности. Эти элементы добавляются прямо в заголовок XML (<soap:Header>), обеспечивая безопасность на уровне сообщения, независимо от транспортного уровня.

Дополнительно применяются WS-Policy и WS-SecurityPolicy для описания требований к сообщениям. WS-Trust используется, если сервис взаимодействует с Security Token Service, а WS-SecureConversation — если нужно установить защищённый сеанс между клиентом и сервером.

Такие спецификации чаще всего применяются при интеграции с банковскими, государственными или корпоративными системами, где требуется строгий контроль безопасности и соответствие стандартам.

[К оглавлению](#WebService)

# 8. Какие существуют методы оптимизации производительности REST сервисов?

1. Кэширование (Caching)

   Использование HTTP-заголовков:

        Cache-Control, ETag, Last-Modified

   Позволяет избежать повторных запросов к серверу, если данные не изменились.

   Пример: браузер или CDN может кэшировать GET /products.

🔹 2. Пагинация, фильтрация и сортировка

    Не возвращай «всё сразу».

    Разбей результат: GET /products?page=1&size=20&sort=name,asc

    Особенно важно для списков, чтобы не грузить сеть и базу.

🔹 3. Сжатие ответа (GZIP)

    Устанавливай заголовок Content-Encoding: gzip

    Снижение объёма ответа до ~70%

    Spring Boot: достаточно добавить server.compression.enabled=true

🔹 4. Асинхронная обработка

    Используй @Async, CompletableFuture, реактивный подход (WebFlux), если запрос длительный.

    Например, отправка email — не блокирует HTTP-поток.

🔹 5. Вынос тяжёлых запросов в очереди

    Если REST-запрос инициирует сложную операцию — отправь задачу в Kafka/RabbitMQ и верни 202 Accepted.

🔹 6. HTTP/2, Keep-Alive

    Улучшение сетевого взаимодействия (особенно при множестве запросов).

    Используется автоматически на современных серверах.

🔹 7. Оптимизация запросов к базе

    Использование JOIN FETCH, индексирование, лимитирование выборок.

    Избегай N+1 проблем (в JPA это боль).

🔹 8. DTO и сериализация

    Отдавай только нужные поля (DTO, MapStruct, Jackson views).

    Уменьшай размер payload'а.

🔹 9. Rate limiting / Throttling

    Защита от перегрузки и DDoS.

    Ограничивай количество запросов от одного клиента.

[К оглавлению](#WebService)

# 9. В чем состоят сложности миграции с SOAP на REST и как их можно преодолеть?

Основные сложности миграции SOAP → REST:

    Разные модели взаимодействия:

        SOAP ориентирован на операции (RPC-стиль) — вызов методов.

        REST ориентирован на ресурсы и их состояния (resource-oriented).
        Нужно перестраивать логику с вызова операций на работу с ресурсами и их состояниями.

    Разный формат данных:

        SOAP использует только XML.

        REST чаще работает с JSON, который легче и более гибкий.
        Придётся реализовать преобразование форматов и адаптировать клиент и сервер.

    Отсутствие WSDL и строгих контрактов в REST:

        В SOAP контракт описан в WSDL — четкие схемы, операции, типы.

        В REST контракт менее формализован, часто используется OpenAPI/Swagger.
        Нужно тщательно описать и задокументировать новый REST API.

    Безопасность и транзакционность:

        SOAP часто использует WS-Security, транзакции, надежную доставку.

        REST базируется на HTTPS и OAuth2/JWT, нет встроенной поддержки транзакций.
        Нужно переосмыслить требования безопасности и согласовать с командами.

    Клиентские адаптации:

        Существующие клиенты SOAP — используют генерацию классов по WSDL.

        REST-клиенты требуют другой подход (например, через HTTP-клиенты, Retrofit, WebClient).
        Потребуется переписать или адаптировать клиентов.

    Обработка ошибок:

        SOAP использует стандартизированный <soap:Fault>.

        В REST ошибки передаются через HTTP-коды и тело ответа.
        Нужно согласовать новый формат ошибок и изменить обработку.

### Как преодолеть сложности:

    Постепенный переход:
    Ввести REST API параллельно SOAP, чтобы клиенты могли мигрировать постепенно.

    Использовать API Gateway или прокси, которые конвертируют REST-вызовы в SOAP и обратно (мост).

    Тщательное документирование REST API (OpenAPI/Swagger).

    Автоматизация тестирования для обоих протоколов.

    Переписывать клиентскую часть поэтапно, чтобы минимизировать риски.

[К оглавлению](#WebService)

# 10. Что такое SOAP в контексте веб-сервисов?

SOAP (Simple Object Access Protocol) — это протокол обмена сообщениями, основанный на XML, который используется для организации взаимодействия между клиентом и сервером в веб-сервисах. Он определяет строго структурированные сообщения с заголовками и телом (envelope, header, body), использует WSDL для описания интерфейса, и поддерживает стандарты безопасности (WS-Security), транзакций и надежной доставки сообщений.

[К оглавлению](#WebService)

# 11. Какие основные преимущества использования SOAP перед REST?

Основные преимущества SOAP — это наличие строгого контракта через WSDL, который упрощает интеграцию с множеством клиентов и позволяет чётко описывать методы и типы.

SOAP предлагает расширенные стандарты безопасности — WS-Security — с поддержкой подписей и шифрования на уровне сообщения, что особенно важно в банковских и корпоративных системах.

Также SOAP обеспечивает надёжную доставку и поддержку транзакций через стандарты WS-ReliableMessaging и WS-AtomicTransaction.

Кроме того, SOAP не привязан к HTTP и может работать через другие протоколы, что даёт дополнительную гибкость.

[К оглавлению](#WebService)

# 12. Какие стандарты используются в SOAP для обмена сообщениями?

XML (Extensible Markup Language)
Формат представления сообщений. SOAP — это XML-документ с определённой структурой (Envelope, Header, Body).

SOAP Envelope
Определяет структуру SOAP-сообщения — корневой элемент, содержащий заголовок и тело.

WSDL (Web Services Description Language)
Описывает интерфейс сервиса: операции, типы данных, протоколы, endpoint.

SOAP Encoding
Способ кодирования данных внутри SOAP-сообщения.

WS-Security
Стандарты для безопасности сообщений: подпись, шифрование, токены.

XML Schema (XSD)
Определение структуры и типов данных в сообщениях.

WS-Addressing
Стандарты для маршрутизации сообщений, метаданных адресации.

[К оглавлению](#WebService)

# 13. Какие инструменты используются для создания SOAP веб-сервисов в Java?

JAX-WS (Java API for XML Web Services)
Стандартный Java API для создания SOAP сервисов и клиентов. Позволяет легко создавать серверные и клиентские классы, поддерживает аннотации @WebService, @WebMethod. Входит в состав JDK (до Java 11), в новых версиях требует добавления зависимости.

Apache CXF
Популярный фреймворк для SOAP и REST веб-сервисов. Хорошо интегрируется с Spring, поддерживает WS-Security, WS-ReliableMessaging и другие WS-* стандарты. Позволяет генерировать код из WSDL и наоборот.

Metro
Стек веб-сервисов от Oracle, реализующий JAX-WS и WS-* спецификации. Используется для создания и поддержки SOAP сервисов.

Spring-WS
Фреймворк от Spring для создания SOAP сервисов с акцентом на контрактно-ориентированную разработку. Позволяет работать с чистыми XML (без необходимости генерации классов), хорошо подходит для интеграции с существующими WSDL.

wsimport / wsdl2java
Инструменты командной строки для генерации Java классов из WSDL (wsimport — из JDK, wsdl2java — в Apache CXF).

[К оглавлению](#WebService)

# 14. Каковы основные этапы создания SOAP веб-сервиса?

Проектирование контракта (WSDL)

    Определение интерфейса сервиса: операции, типы сообщений, структуры данных.

    Обычно создаётся WSDL-файл, который служит спецификацией API.

Генерация серверных и клиентских классов

    С помощью инструментов wsimport (Java) или wsdl2java (Apache CXF) генерируются Java-классы из WSDL.

    Если сервис создаётся с нуля, можно сначала написать классы и сгенерировать WSDL (Code-First или Contract-First подход).

Реализация логики сервиса

    В классах, реализующих интерфейс сервиса, пишется бизнес-логика методов.

Настройка безопасности (если нужно)

    Добавление WS-Security, подписи, шифрования, аутентификации.

Деплой на сервер приложений

    Сервис разворачивается на сервере, например, Tomcat, WildFly, WebSphere.

Тестирование веб-сервиса

    Использование SOAP UI, Postman (с поддержкой SOAP), JUnit-тесты.

Документирование и публикация WSDL

    WSDL доступен клиентам для интеграции.

[К оглавлению](#WebService)

# 15. Каким образом осуществляется обмен данными между клиентом и сервером в SOAP веб-сервисах?

Формат сообщений — XML
Все сообщения (и запросы, и ответы) — это XML-документы, строго структурированные по стандарту SOAP Envelope, который содержит:

    <Envelope> — корневой элемент

    <Header> — необязательный заголовок для метаданных, безопасности, маршрутизации

    <Body> — основное содержимое с операцией и её параметрами

Транспортный протокол

    Обычно используется HTTP/HTTPS, но SOAP не ограничен транспортом (SMTP, JMS, TCP тоже возможны).

    Запросы идут через HTTP POST, где тело запроса — это SOAP XML.

Обработка на сервере

    Сервер принимает POST-запрос, разбирает XML, выполняет описанную операцию, формирует ответ (также SOAP XML).

Обработка ошибок

    Если что-то пошло не так, сервер отправляет SOAP Fault — специальный XML-блок с описанием ошибки.

[К оглавлению](#WebService)

# 16. Как реализовать безопасность в SOAP веб-сервисах с использованием WS-Security?

WS-Security (Web Services Security) — это стандарт, описывающий, как обеспечивать конфиденциальность, целостность и аутентификацию сообщений в SOAP с помощью XML-расширений.

🔐 Основные механизмы безопасности в WS-Security:

    Аутентификация:

        UsernameToken — передача логина и пароля (в виде хеша или plain-text) в SOAP Header.

        X.509 Certificates — проверка цифровой подписи сообщения с помощью сертификатов.

    Целостность:

        XML Digital Signature — цифровая подпись части или всего SOAP-сообщения, чтобы удостовериться, что оно не было изменено в пути.

    Конфиденциальность:

        XML Encryption — шифрование частей сообщения, обычно <Body>, чтобы скрыть данные от перехвата.

    Timestamp:

        Используется для защиты от повторных атак (Replay Attack). В Header указывается время отправки и срок действия сообщения.

### Как реализуется на практике (например, с Apache CXF):

    Подключаешь зависимости (например, Apache CXF, WSS4J).

    Настраиваешь interceptor, который обрабатывает WS-Security в клиенте и сервере.

    Определяешь политики безопасности (через .properties или policy.xml):

        action=UsernameToken Signature Encrypt Timestamp

        user=myKeyAlias

        passwordCallbackClass=MyPasswordCallback

[К оглавлению](#WebService)

# 17. Какие подходы используются для оптимизации производительности SOAP веб-сервисов?

🔹 1. Формата сообщений

    MTOM (Message Transmission Optimization Mechanism)
    Используется для передачи бинарных данных (например, файлов) — позволяет передавать их не как base64 в XML, а как отдельный MIME-вложенный поток.
    ➤ Это сильно снижает объем передаваемого XML и ускоряет обработку.

    SOAP compression (gzip)
    Сжатие XML-сообщений при передаче по HTTP. Это уменьшает трафик, особенно на медленных линиях.

🔹 2. Сетевого уровня

    Connection pooling
    Повторное использование соединений HTTP между клиентом и сервером (особенно при HTTPS — TLS handshakes дорогие).

    Keep-Alive
    Установка и поддержка длительных TCP-соединений между клиентом и сервером.

🔹 3. Кэширование

    Кэширование WSDL
    Клиенты не скачивают WSDL на каждый вызов.

    Кэширование результатов
    Если сервис идемпотентен, можно использовать промежуточный кэш (на клиенте или API Gateway).

🔹 4. Парсинг и сериализация

    Использование быстрых XML-парсеров (StAX вместо DOM/SAX)
    StAX обрабатывает XML в потоковом режиме, что быстрее и менее затратно по памяти.

    JAXB оптимизация
    Предварительная компиляция JAXB-моделей, отключение ненужных валидаций.

🔹 5. Снижение объема сообщений

    Удаление лишних SOAP-заголовков
    Заголовки часто накапливаются из-за расширений и становятся слишком "жирными".

    Дробление больших сообщений
    Например, вместо одной тяжелой операции с 10k объектов — использовать постраничную отправку.

[К оглавлению](#WebService)

# 18. Как можно реализовать версионирование SOAP веб-сервисов?

🔹 1. Версионирование через namespace (наилучший и стандартный способ)

WSDL и XML Schema позволяют использовать разные XML-пространства имён для каждой версии:
````
Пример:

xmlns:v1="http://example.com/api/v1"
xmlns:v2="http://example.com/api/v2"
````
Каждая версия схемы и типов живёт в своём пространстве. Это позволяет:

    иметь несколько версий параллельно,

    не ломать старых клиентов,

    использовать один и тот же endpoint с разбором версий по namespace.

✅ Плюсы: Чисто, официально, поддерживается всеми SOAP-реализациями.

❌ Минусы: Нужно поддерживать несколько WSDL/XSD.

🔹 2. Версионирование через URL/endpoint

Создаются разные сервисы с разными endpoint'ами:
````
/services/UserService/v1
/services/UserService/v2
````
Каждая версия имеет свой WSDL и URL.

✅ Плюсы: Явно видно версию в URL.

❌ Минусы: Дублирование конфигурации, сложнее обновлять.

🔹 3. Версионирование через OperationName или Header (не рекомендуются)

    Можно ввести доп. параметр version в SOAP-запрос (например, в Header).

    Или добавить к операциям суффикс: getUserV1, getUserV2.

⚠️ Эти подходы слабоформализованы, могут нарушать контракт и усложняют поддержку. Используются как временное решение.

[К оглавлению](#WebService)
 
# 19. Что такое REST?

REST — это архитектурный стиль для построения распределённых систем, основанный на принципах, описанных Роем Филдингом. Он использует HTTP как транспорт и опирается на ключевые идеи, такие как клиент-серверность, stateless, кэшируемость и единообразие интерфейса.

В REST все ресурсы идентифицируются через URI, а действия над ними описываются стандартными HTTP-методами — GET, POST, PUT, DELETE. В качестве формата данных обычно используется JSON.

[К оглавлению](#WebService)

# 20. Перечислите какие-либо коды ответов HTTP и их значения.

| Код | Класс           | Значение                              |
| --- | --------------- | ------------------------------------- |
| 1xx | Информационные  | Продолжаем обмен (редко используются) |
| 2xx | Успех           | Запрос обработан успешно              |
| 3xx | Перенаправления | Клиенту нужно перейти по другому URL  |
| 4xx | Ошибка клиента  | Неверный запрос со стороны клиента    |
| 5xx | Ошибка сервера  | Проблема на стороне сервера           |


200 OK
Запрос выполнен успешно, и в теле есть результат.
→ Например, GET /users/1.

201 Created
Ресурс создан. Часто возвращается при POST.
→ Например, POST /users создаёт пользователя.

204 No Content
Успешно, но без тела ответа.
→ Например, DELETE /users/1.

400 Bad Request
Некорректный запрос (например, JSON невалидный).

401 Unauthorized
Неавторизован — нужно предоставить токен/логин.
→ Нет JWT, нет Basic-авторизации и т.п.

403 Forbidden
Доступ запрещён — даже если авторизован.
→ Например, у пользователя нет нужной роли.

404 Not Found
Ресурс не найден.

409 Conflict
Конфликт при обработке — например, уже существует такой объект.

422 Unprocessable Entity (чаще в REST)
Валидация не прошла, хотя запрос синтаксически верный.

500 Internal Server Error
Общая ошибка сервера.
→ Например, NPE или ошибка в бизнес-логике.

502 Bad Gateway
Проблема на промежуточном прокси.

503 Service Unavailable
Сервер временно недоступен (например, при перегрузке или на обслуживании).

[К оглавлению](#WebService)

# 21. Какие HTTP методы считаются идемпотентными?

Идемпотентные методы — это такие, которые при повторном вызове не изменяют состояние сервера. К ним относятся:

    GET — просто возвращает данные

    PUT — перезаписывает ресурс, результат не меняется

    DELETE — после первого удаления последующие вызовы ничего не меняют

    HEAD и OPTIONS тоже идемпотентны, так как не вносят изменений

POST не является идемпотентным, так как обычно используется для создания ресурса, и каждый вызов может создавать новый объект.

[К оглавлению](#WebService)

# 22. Как в контексте REST применяются принципы безопасности и идемпотентности?

#### Принципы безопасности в REST

В REST безопасность чаще всего реализуется на уровне HTTP и заголовков, а также за счёт архитектурных решений.

🔒 Основные меры:

🔹 Аутентификация

REST не навязывает конкретный способ — популярны:

    JWT (Bearer-токены) — отправляется в Authorization: Bearer <token>

    OAuth 2.0 — особенно в распределённых системах

    Basic Auth — простая, но устаревшая и небезопасная без HTTPS

🔹 Авторизация

После аутентификации — проверяется, имеет ли пользователь доступ к ресурсу.

    Примеры: роль ADMIN, доступ только к своим данным.

🔹 Шифрование

    Используется HTTPS — обязательно!

    REST не должен работать по HTTP в продакшене.

🔹 CORS

    Контролирует, с каких доменов можно обращаться к API.

    Важен для публичных API.

🔹 Rate limiting / Throttling

    Ограничение количества запросов — защищает от DDoS и brute force.

🔹 Валидация входных данных

    Предотвращает атаки типа XSS, SQL-инъекций и т.п.

#### Применение идемпотентности в REST

Идемпотентность — критически важна для:

    Надёжности в условиях нестабильной сети

    Повторной отправки запросов (например, retry-механизмов)

    Построения кэшируемых, предсказуемых API

| Метод    | Как использовать идемпотентность                                                                                          |
| -------- | ------------------------------------------------------------------------------------------------------------------------- |
| `GET`    | Безопасен, используется для чтения                                                                                        |
| `PUT`    | Обновление ресурса — даже если клиент отправил запрос повторно, состояние останется тем же                                |
| `DELETE` | Повторное удаление не приведёт к ошибкам                                                                                  |
| `POST`   | Не идемпотентен — **если нужно сделать его устойчивым к повтору**, применяют `Idempotency-Key` (например, Stripe, PayPal) |


[К оглавлению](#WebService)

# 23. Каково значение и использование кода ответа HTTP 204?

Код ответа 204 No Content означает, что запрос обработан успешно, но в теле ответа нет содержимого.

Он обычно используется при DELETE, PUT, PATCH — когда сервер подтверждает действие, но не возвращает данные. Например:

    DELETE /user/123 может вернуть 204, если пользователь удалён.

    PUT /user/123 может вернуть 204, если обновление прошло успешно и клиенту не нужны свежие данные.

[К оглавлению](#WebService)

# 24. В чем разница между методами PUT и PATCH в контексте REST?

PUT — это полная замена ресурса. Всё, что не передано, будет сброшено. Метод идемпотентен, и при повторном вызове результат не изменится.

PATCH — это частичное обновление. Обновляются только указанные поля. Метод обычно идемпотентен, но это не гарантировано.

[К оглавлению](#WebService)

# 25. Как REST использует принципы единообразия интерфейса и беспостредственного управления ресурсами?

Единообразие интерфейса (Uniform Interface) — взаимодействие между клиентом и сервером стандартизировано через HTTP-методы. Все ресурсы управляются через GET, POST, PUT, DELETE, и доступны по URI. Это упрощает реализацию и уменьшает связность между клиентом и сервером.

Беспосредственное управление ресурсами — REST оперирует не методами, а сущностями. Клиент взаимодействует напрямую с ресурсами через URI, и сервер отвечает за представление состояния этих ресурсов. Например, GET /users/1 возвращает пользователя, а PUT /users/1 его обновляет.

[К оглавлению](#WebService)
 
# 26. Какие существуют подходы к обработке версионирования в RESTful API?

1. 📌 URI-версионирование (URL Path Versioning)

Пример:

GET /api/v1/users

Плюсы:

    Простая реализация

    Клиенты явно указывают версию

    Легко кэшируется

Минусы:

    Нарушает REST-принцип: URI = ресурс, а не его версия

    Может быть дублирование URI/логики

    ✅ Самый популярный способ. Прост и удобен.

2. 🧾 Параметр запроса (Query Parameter Versioning)

Пример:

GET /users?version=1

Плюсы:

    Можно быстро протестировать или переключать версии

Минусы:

    Сложнее кэшировать

    Не RESTful (ресурсы не должны зависеть от query-параметров)

    ⚠️ Используется редко. Уместен только в dev/debug режимах.

3. 📨 Заголовок (Header Versioning / Custom Header)

Пример:
````
GET /users
Headers:
Accept: application/vnd.company.v1+json
````
Плюсы:

    Чистые URI

    Хорошо вписывается в REST-стиль

Минусы:

    Требует настройки клиента

    Не всегда удобно тестировать вручную

    💡 Часто используется в больших публичных API, например GitHub, Stripe

4. ⚙️ Content Negotiation (MIME type versioning)

Пример:

Accept: application/vnd.myapp.resource-v2+json

Плюсы:

    Поддерживает чистую структуру URI

    Гибкость

Минусы:

    Сложнее реализовать и тестировать

    Сложнее кэшировать

    🧠 Используется реже, но это самый REST-идеологичный способ.

[К оглавлению](#WebService)

# 27. Опишите, как в RESTful веб-сервисах реализуется кеширование и его влияние на производительность.


#### Основные механизмы кеширования

1. Cache-Control

   Управляет стратегией кеша:

        no-cache – кешировать можно, но нужно валидировать на сервере

        no-store – вообще не кешировать

        max-age=3600 – хранить в кеше 1 час

        public, private – кто может кешировать

2. ETag и If-None-Match

   Сервер отдает ETag (уникальный хеш версии ресурса)

   При следующем запросе клиент отправляет If-None-Match

   Если ресурс не изменился → 304 Not Modified, и клиент использует кеш

3. Last-Modified и If-Modified-Since

   Альтернатива ETag: время последнего изменения

   Меньше точности, но проще

4. Expires

   Указывает абсолютное время, когда ресурс считается устаревшим (устаревший механизм, заменён Cache-Control)

#### Влияние на производительность

Кеширование:

    💨 Уменьшает нагрузку на сервер (меньше обращений к БД и логике)

    🚀 Ускоряет ответы (особенно для GET-запросов)

    🔁 Повышает масштабируемость API

    🧩 Может использоваться в CDN, прокси, браузерах

🔧 Где это используется?

    GET-запросы к часто запрашиваемым данным (напр. профили пользователей)

    Справочники, статические данные

    Документы, изображения, конфиги

[К оглавлению](#WebService)

# 28. Объясните, что такое HATEOAS?

HATEOAS — это принцип REST, согласно которому клиент получает не только данные, но и ссылки на допустимые действия с этими данными. Это делает API самоописательным: клиент не должен "угадывать" URL-ы и может полностью полагаться на гипермедиа, получаемую от сервера.

В Spring HATEOAS это реализуется с помощью EntityModel и добавления _links в ответ.

[К оглавлению](#WebService)

# 29. Что такое протокол HTTP?

HTTP — это прикладной протокол клиент-серверного взаимодействия, основанный на модели запрос–ответ. Он используется для передачи данных между клиентами (браузерами, API-клиентами) и серверами.

HTTP поддерживает различные методы, такие как GET, POST, PUT, и работает с заголовками, кодами ответов и телом сообщений.

[К оглавлению](#WebService)

# 30. Каковы основные методы запросов HTTP?

🔹 GET

    Получение информации

    Никогда не изменяет состояние на сервере

    Кэшируемый

    Пример: GET /users/123

🔹 POST

    Создание ресурса

    Может изменять состояние (создаёт запись, запускает операцию)

    Не идемпотентен (два одинаковых запроса → 2 ресурса)

    Пример: POST /users с телом {"name": "Denis"}

🔹 PUT

    Полная замена ресурса по ID

    Идемпотентен (один или 10 одинаковых запросов — один результат)

    Пример: PUT /users/123

🔹 PATCH

    Частичное обновление ресурса

    Неидемпотентный (зависит от реализации)

    Пример: PATCH /users/123 с телом {"email": "new@example.com"}

🔹 DELETE

    Удаляет ресурс

    Идемпотентен (удаление несколько раз не приведёт к ошибке)

    Пример: DELETE /users/123

🔹 HEAD

    Возвращает только заголовки, без тела ресурса

    Используется для проверки существования или метаданных (например, перед скачиванием файла)

🔹 OPTIONS

    Возвращает список доступных методов для ресурса

    Применяется в CORS (предварительный запрос браузера)

[К оглавлению](#WebService)

# 31. Что такое статус-код в ответе HTTP?

HTTP статус-код — это число в ответе сервера, обозначающее результат обработки запроса.
Они делятся на пять классов: информационные (1xx), успешные (2xx), редиректы (3xx), ошибки клиента (4xx), ошибки сервера (5xx).

[К оглавлению](#WebService)

# 32. Как работает механизм перенаправления (редиректа) в HTTP?

#### Как работает пошагово

Клиент отправляет HTTP-запрос (например, GET /old-page)

Сервер возвращает статус-код из серии 3xx, например:
````
HTTP/1.1 301 Moved Permanently  
Location: https://new-site.com/new-page
````
Клиент (например, браузер или Postman) автоматически делает второй запрос по Location.

[К оглавлению](#WebService)

# 33. В чем разница между HTTP и HTTPS?

HTTP — это протокол передачи данных, но без защиты.

HTTPS — это тот же протокол, но работающий поверх TLS/SSL, обеспечивая шифрование, защиту от подмены и аутентификацию сервера.

В боевой среде все REST API, особенно с авторизацией и персональными данными, обязательно работают через HTTPS (порт 443).

[К оглавлению](#WebService)

# 34. Какие существуют типы содержимого (Content-Type) в HTTP?

Content-Type — это HTTP-заголовок, который указывает формат данных, передаваемых в теле запроса или ответа. Он обязателен, если в теле есть данные (POST, PUT, PATCH).

| Тип                                 | Назначение                                                      |
| ----------------------------------- | --------------------------------------------------------------- |
| `application/json`                  | JSON. Самый часто используемый в REST API                       |
| `application/xml`                   | XML. Используется в SOAP, некоторых старых системах             |
| `application/x-www-form-urlencoded` | Стандартная форма HTML (ключ=значение&ключ2=значение)           |
| `multipart/form-data`               | Используется для загрузки файлов или смешанных данных (в форме) |
| `text/plain`                        | Простой текст                                                   |
| `text/html`                         | HTML-страница (например, сервер возвращает HTML браузеру)       |
| `application/octet-stream`          | Бинарные данные, используется для файлов, байтовых массивов     |


#### Где ты с этим сталкиваешься в Java

Spring Controller:
````
@PostMapping(value = "/json", consumes = MediaType.APPLICATION_JSON_VALUE)
public ResponseEntity<?> postJson(@RequestBody MyDto dto) { ... }
````
RestTemplate, WebClient:
````
headers.setContentType(MediaType.APPLICATION_JSON);
````
Multipart загрузка файла:
````
@PostMapping(value = "/upload", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
public void upload(@RequestParam MultipartFile file) { ... }
````
[К оглавлению](#WebService)
 
# 35. Как реализован механизм сжатия данных в HTTP и какие алгоритмы сжатия обычно используются?

Сжатие данных в HTTP реализуется через заголовки:

🔹 Клиент → Сервер:
````
Accept-Encoding: gzip, deflate, br
````
Клиент сообщает, какие алгоритмы он поддерживает.

🔹 Сервер → Клиент:
````
Content-Encoding: gzip
````
Сервер сжимает тело ответа и сообщает, какой алгоритм применён.

#### Популярные алгоритмы сжатия:

| Алгоритм      | Описание                                                                  |
| ------------- | ------------------------------------------------------------------------- |
| `gzip`        | Наиболее распространённый, эффективен и широко поддерживается             |
| `deflate`     | Немного быстрее gzip, но используется реже                                |
| `br` (Brotli) | Новый алгоритм от Google, лучше сжимает, но дольше работает               |
| `zstd`        | Современный алгоритм от Facebook, высокая скорость и сжатие (реже в HTTP) |


#### Как это выглядит в Java (например, Spring Boot)

В Spring Boot я включаю сжатие через server.compression.* в application.yml, особенно для JSON-ответов, чтобы сократить трафик и ускорить отклик.

```java
Сжатие ответов (включается в application.yml):

server:
    compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/plain
    min-response-size: 1024
```

[К оглавлению](#WebService)

# 36. Какие механизмы безопасности используются в HTTPS?

| Механизм                            | Назначение                                                                                         |
| ----------------------------------- | -------------------------------------------------------------------------------------------------- |
| **Шифрование (Encryption)**         | Данные шифруются, чтобы их нельзя было перехватить в открытом виде                                 |
| **Аутентификация (Authentication)** | Гарантирует, что клиент общается именно с тем сервером, за кого он себя выдаёт (через сертификаты) |
| **Целостность (Integrity)**         | Обеспечивается с помощью **MAC/Hash**, чтобы никто не изменил данные «на лету»                     |
| **Обмен ключами (Key Exchange)**    | Защищённая генерация и передача сессионного ключа (обычно через RSA, ECDHE)                        |


#### Как это работает

    🔐 TLS Handshake: при первом подключении клиент и сервер договариваются об алгоритмах шифрования.

    🧾 Сервер отправляет сертификат (X.509), подписанный доверенным центром сертификации (CA).

    🧠 Клиент проверяет подлинность (доверяет ли CA).

    🤝 Генерируется сессионный ключ, которым шифруется весь дальнейший трафик.

    📦 Все HTTP-запросы/ответы идут внутри защищённого TLS-туннеля.

#### Что защищает HTTPS

    Логины, пароли, токены (JWT, OAuth)

    REST/GraphQL/SOAP-переписку

    Cookies с авторизацией (HttpOnly, Secure)

    Банковские операции, номера карт и т. п.

[К оглавлению](#WebService)

# 37. Какие нововведения были введены в HTTP/2 по сравнению с HTTP/1.1?

Главное отличие HTTP/2 от HTTP/1.1 — повышенная производительность и оптимизация передачи данных.

| HTTP/2 Фича                     | Что делает                                                                                             |
| ------------------------------- | ------------------------------------------------------------------------------------------------------ |
| ✅ **Бинарный протокол**         | Вместо текстового — компактный и эффективный бинарный формат сообщений                                 |
| ✅ **Мультиплексирование**       | Несколько запросов и ответов могут передаваться по одному TCP-соединению одновременно (без блокировок) |
| ✅ **Сжатие заголовков (HPACK)** | Уменьшает объём HTTP-заголовков — особенно важно для REST API                                          |
| ✅ **Server Push**               | Сервер может сам отправить ресурсы до запроса клиента (например, CSS/JS)                               |
| ✅ **Приоритеты потоков**        | Потоки можно приоритизировать, например, сначала HTML, потом картинки                                  |
| ✅ **Одно соединение**           | Всё взаимодействие клиента и сервера через **одно TCP-соединение** вместо многих в HTTP/1.1            |


[К оглавлению](#WebService)