## AutoboxingUnboxing

[1. Что такое автоупаковка (autoboxing) и автораспаковка (unboxing) в Java?](#1-что-такое-автоупаковка-autoboxing-и-автораспаковка-unboxing-в-java)

[2. Какие типы данных поддерживают операции автоупаковки и автораспаковки в Java?](#2-какие-типы-данных-поддерживают-операции-автоупаковки-и-автораспаковки-в-java)

[3. Приведите пример использования автоупаковки в Java.](#3-приведите-пример-использования-автоупаковки-в-java)

[4. Какая основная разница между примитивными типами и их оберточными классами в контексте автоупаковки и автораспаковки?](#4-какая-основная-разница-между-примитивными-типами-и-их-оберточными-классами-в-контексте-автоупаковки-и-автораспаковки)

[5. Как операция автораспаковки может привести к исключению NullPointerException?](#5-как-операция-автораспаковки-может-привести-к-исключению-nullpointerexception)

[6. Каким образом использование автоупаковки и автораспаковки влияет на производительность приложения?](#6-каким-образом-использование-автоупаковки-и-автораспаковки-влияет-на-производительность-приложения)

[7. Объясните, как работает кэширование при автоупаковке целочисленных типов данных в Java.](#7-объясните-как-работает-кэширование-при-автоупаковке-целочисленных-типов-данных-в-java)

[8. Какие потенциальные проблемы могут возникнуть при сравнении объектов оберточных классов, полученных через автоупаковку?](#8-какие-потенциальные-проблемы-могут-возникнуть-при-сравнении-объектов-оберточных-классов-полученных-через-автоупаковку)

[9. В каких случаях предпочтительно избегать автоупаковки и автораспаковки для оптимизации производительности приложения?](#9-в-каких-случаях-предпочтительно-избегать-автоупаковки-и-автораспаковки-для-оптимизации-производительности-приложения)

# 1. Что такое автоупаковка (autoboxing) и автораспаковка (unboxing) в Java?

- Автоупаковка - примитивный тип ⇒ объектный класс
- Автораспаковка - объектный класс ⇒ примитивный тип

[К оглавлению](#AutoboxingUnboxing)

# 2. Какие типы данных поддерживают операции автоупаковки и автораспаковки в Java?

Для всех 8 примитивных типов:

- byte -> Byte
- short -> Short
- int -> Integer
- long -> Long
- float -> Float
- double -> Double
- char -> Character
- boolean -> Boolean

[К оглавлению](#AutoboxingUnboxing)

# 3. Приведите пример использования автоупаковки в Java.

- Автоупаковка позволяет передавать примитивы в параметры, ожидающие объекты-обертки

```java
public void printWrapper(Integer number) {
    System.out.println(number);
}

// Вызов:
printWrapper(123); // Автоупаковка: int → Integer
```

- Даже если переменные объявлены как классы-обертки, автоупаковка/распаковка позволяет работать с ними как с примитивами

```java
Integer a = 10;
Integer b = 20;
int sum = a + b; // Автораспаковка a и b, сложение, результат (int)
Integer result = a * b; // Автораспаковка, умножение, автоупаковка результата
```

- Integer integer = 9;

[К оглавлению](#AutoboxingUnboxing)

# 4. Какая основная разница между примитивными типами и их оберточными классами в контексте автоупаковки и автораспаковки?

`Примитивы`

- Хранятся в стеке (stack), занимают фиксированный размер
- Не могут быть `null`, всегда имеют значение по умолчанию
- Не могут использоваться в дженерика.
- Быстрые операции, нет накладных расходов
- Сравниваются через `==`

`Обертки`

- Хранятся в куче (heap) как объекты, что требует дополнительной памяти
- Могут быть `null`, что приводит к `NullPointerException` при автораспаковке
- Используются в дженериках.
- Автоупаковка/распаковка создает временные объекты, что замедляет код в циклах
- Сравниваются через `equals()`

[К оглавлению](#AutoboxingUnboxing)

# 5. Как операция автораспаковки может привести к исключению NullPointerException?

Если объект-обертка равен null, а Java пытается его распаковать, возникает NullPointerException (NPE), потому что под
капотом вызывается метод обертки (например, intValue()), который не может работать с null.

[К оглавлению](#AutoboxingUnboxing)

# 6. Каким образом использование автоупаковки и автораспаковки влияет на производительность приложения?

- Каждая автоупаковка создает новый объект в куче. Частая упаковка/распаковка в циклах или горячих участках кода
  генерирует множество временных объектов, что увеличивает нагрузку на сборщик мусора (GC).
- Автоупаковка/распаковка добавляет скрытые вызовы методов (например, Integer.valueOf(), intValue()), что замедляет
  выполнение кода по сравнению с работой напрямую с примитивами

[К оглавлению](#AutoboxingUnboxing)

# 7. Объясните, как работает кэширование при автоупаковке целочисленных типов данных в Java.

Когда происходит автоупаковка (например, int → Integer), Java сначала проверяет, попадает ли значение в кешируемый
диапазон. Если да — возвращается объект из пула, если нет — создается новый.

Кэш хранится в статическом массиве внутри класса-обертки.

[К оглавлению](#AutoboxingUnboxing)

# 8. Какие потенциальные проблемы могут возникнуть при сравнении объектов оберточных классов, полученных через автоупаковку?

- Оператор == сравнивает ссылки на объекты, а не их значения. Из-за кэширования оберток для некоторых значений (
  например, Integer от -128 до 127) сравнение может давать разные результаты для одинаковых чисел.
- При сравнении оберток разных типов (например, Integer и Long) equals() вернет false, даже если числовые значения
  равны.
- Если один из объектов null, вызов equals() или попытка распаковки вызовет исключение.
- В условных операторах (>, <, >=, <=) происходит автораспаковка, что может привести к NPE, если объект null.
- Частые автоупаковка/распаковка в циклах или массовых сравнениях создают временные объекты, что снижает
  производительность.

[К оглавлению](#AutoboxingUnboxing)

# 9. В каких случаях предпочтительно избегать автоупаковки и автораспаковки для оптимизации производительности приложения?

- Если часто выполняешь арифметические операции или сравнения с примитивами, то использование обёрток (Integer,
  Double и т. д.) приведет к лишним преобразованиям типов, что замедлит выполнение программы.
- При работе с коллекциями, такими как ArrayList, лучше избегать автоупаковки, если тебе нужно обрабатывать большое
  количество данных. Например, если ты используешь `List<Integer>`, каждый элемент будет упакован в Integer — это создаёт
  дополнительные объекты и увеличивает нагрузку на память.
  Для работы с коллекциями примитивов лучше использовать специализированные коллекции, такие как IntList (из библиотек
  типа Trove или FastUtil) или другие библиотеки, оптимизированные для работы с примитивами.
- Если часто работаешь с числовыми значениями в циклах, где каждое число требует автоупаковки/распаковки, это может значительно снизить производительность.

[К оглавлению](#AutoboxingUnboxing)