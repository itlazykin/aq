## JpaHibernate

[1. Что такое JPA и для чего она используется?](#1-что-такое-jpa-и-для-чего-она-используется)

[2. Какие основные преимущества использования JPA по сравнению с JDBC?](#2-какие-основные-преимущества-использования-jpa-по-сравнению-с-jdbc)

[3. Как определить сущность в JPA?](#3-как-определить-сущность-в-jpa)

[4. Какие стратегии наследования поддерживает JPA?](#4-какие-стратегии-наследования-поддерживает-jpa)

[5. Как реализовать отношения один-ко-многим в JPA?](#5-как-реализовать-отношения-один-ко-многим-в-jpa)

[6. Как работает кэширование в JPA и какие типы кэшей поддерживаются?](#6-как-работает-кэширование-в-jpa-и-какие-типы-кэшей-поддерживаются)

[7. Как можно интегрировать пользовательские SQL запросы в JPA?](#7-как-можно-интегрировать-пользовательские-sql-запросы-в-jpa)

[8. Какие подходы к оптимистичной и пессимистичной блокировке поддерживаются в JPA?](#8-какие-подходы-к-оптимистичной-и-пессимистичной-блокировке-поддерживаются-в-jpa)

[9. Как реализовать мульти-тенантность в приложении с использованием JPA?](#9-как-реализовать-мульти-тенантность-в-приложении-с-использованием-jpa)

[10. Расскажите что такое FetchType?](#10-расскажите-что-такое-fetchtype)

[11. Опишите, какие состояния Entity существуют в Hibernate?](#11-опишите-какие-состояния-entity-существуют-в-hibernate)

[12. Что такое Hibernate и какие основные преимущества он предлагает?](#12-что-такое-hibernate-и-какие-основные-преимущества-он-предлагает)

[13. Опишите, какой FetchType по умолчанию при каждой связи между двумя сущностями?](#13-опишите-какой-fetchtype-по-умолчанию-при-каждой-связи-между-двумя-сущностями)

[14. Расскажите что такое каскадирование и как каскадные операции влияют на управление данными в БД?](#14-расскажите-что-такое-каскадирование-и-как-каскадные-операции-влияют-на-управление-данными-в-бд)

[15. Что такое встраиваемый (Embeddable) класс?](#15-что-такое-встраиваемый-embeddable-класс)

[16. Какие стратегии наследования имеются в Hibernate?](#16-какие-стратегии-наследования-имеются-в-hibernate)

[17. Для чего нужны callback методы в Hibernate? К каким сущностям применяются аннотации callback методов?](#17-для-чего-нужны-callback-методы-в-hibernate-к-каким-сущностям-применяются-аннотации-callback-методов)

[18. Расскажите, что такое EntityGraph?](#18-расскажите-что-такое-entitygraph)

[19. Какие виды кэша есть в Hibernate и какими способами.](#19-какие-виды-кэша-есть-в-hibernate-и-какими-способами)

[20. Какие варианты настройки есть для второго уровеня кэша?](#20-какие-варианты-настройки-есть-для-второго-уровеня-кэша)

[21. Что такое стратегия наследования в контексте JPA / Hibernate?](#21-что-такое-стратегия-наследования-в-контексте-jpa--hibernate)

[22. Каковы основные стратегии наследования, поддерживаемые JPA?](#22-каковы-основные-стратегии-наследования-поддерживаемые-jpa)

[23. Как указать стратегию наследования в JPA с помощью аннотаций?](#23-как-указать-стратегию-наследования-в-jpa-с-помощью-аннотаций)

[24. Какие преимущества и недостатки имеет стратегия SINGLE_TABLE при использовании в JPA / Hibernate?](#24-какие-преимущества-и-недостатки-имеет-стратегия-single_table-при-использовании-в-jpa--hibernate)

[25. Как работает стратегия JOINED в контексте наследования сущностей в JPA / Hibernate?](#25-как-работает-стратегия-joined-в-контексте-наследования-сущностей-в-jpa--hibernate)

[26. В чем различие между стратегиями TABLE_PER_CLASS и SINGLE_TABLE в JPA?](#26-в-чем-различие-между-стратегиями-table_per_class-и-single_table-в-jpa)

[27. Какие особенности реализации стратегии наследования TABLE_PER_CLASS в Hibernate по сравнению с другими стратегиями?](#27-какие-особенности-реализации-стратегии-наследования-table_per_class-в-hibernate-по-сравнению-с-другими-стратегиями)

[28. Как стратегия наследования влияет на производительность запросов в JPA / Hibernate?](#28-как-стратегия-наследования-влияет-на-производительность-запросов-в-jpa--hibernate )

[29. Как реализовать кастомную стратегию наследования в JPA / Hibernate, не предусмотренную стандартом?](#29-как-реализовать-кастомную-стратегию-наследования-в-jpa--hibernate-не-предусмотренную-стандартом)

[30. Что такое стратегия генерации ID в контексте JPA?](#30-что-такое-стратегия-генерации-id-в-контексте-jpa)

[31. Какие вы знаете стратегии генерации ID, предоставляемые JPA?](#31-какие-вы-знаете-стратегии-генерации-id-предоставляемые-jpa)

[32. Для чего используется аннотация @GeneratedValue в JPA?](#32-для-чего-используется-аннотация-generatedvalue-в-jpa)

[33. Как работает стратегия AUTO для генерации ID в JPA?](#33-как-работает-стратегия-auto-для-генерации-id-в-jpa)

[34. В чем разница между стратегиями SEQUENCE и TABLE для генерации ID в JPA?](#34-в-чем-разница-между-стратегиями-sequence-и-table-для-генерации-id-в-jpa)

[35. Как настроить кастомный генератор ID в JPA, используя @GenericGenerator?](#35-как-настроить-кастомный-генератор-id-в-jpa-используя-genericgenerator)

[36. Какие преимущества и недостатки у стратегии IDENTITY с точки зрения производительности в JPA?](#36-какие-преимущества-и-недостатки-у-стратегии-identity-с-точки-зрения-производительности-в-jpa)

[37. Как стратегия SEQUENCE генерации ID влияет на возможность оптимистичной блокировки в JPA?](#37-как-стратегия-sequence-генерации-id-влияет-на-возможность-оптимистичной-блокировки-в-jpa)

[38. В каких случаях предпочтительно использовать стратегию TABLE для генерации ID и почему?](#38-в-каких-случаях-предпочтительно-использовать-стратегию-table-для-генерации-id-и-почему)

[39. Что такое LazyInitializationException в контексте JPA / Hibernate?](#39-что-такое-lazyinitializationexception-в-контексте-jpa--hibernate)

[40. Какие основные причины возникновения LazyInitializationException?](#40-какие-основные-причины-возникновения-lazyinitializationexception)

[41. Какие есть способы предотвращения LazyInitializationException без изменения стратегии загрузки?](#41-какие-есть-способы-предотвращения-lazyinitializationexception-без-изменения-стратегии-загрузки)

[42. Как работает ленивая загрузка (lazy loading) в Hibernate и когда она может привести к LazyInitializationException?](#42-как-работает-ленивая-загрузка-lazy-loading-в-hibernate-и-когда-она-может-привести-к-lazyinitializationexception)

[43. Какие есть способы обработки LazyInitializationException в Spring-приложении?](#43-какие-есть-способы-обработки-lazyinitializationexception-в-spring-приложении)

[44. Как можно использовать Hibernate.initialize() для решения проблемы LazyInitializationException?](#44-как-можно-использовать-hibernateinitialize-для-решения-проблемы-lazyinitializationexception)

[45. Как можно использовать паттерн Open Session In View для решения проблемы LazyInitializationException, и какие у этого подхода могут быть недостатки?](#45-как-можно-использовать-паттерн-open-session-in-view-для-решения-проблемы-lazyinitializationexception-и-какие-у-этого-подхода-могут-быть-недостатки)

[46. В каких случаях использование @Transactional может помочь в решении проблемы LazyInitializationException и как правильно его применять?](#46-в-каких-случаях-использование-transactional-может-помочь-в-решении-проблемы-lazyinitializationexception-и-как-правильно-его-применять)

[47. Какие есть способы оптимизации работы с данными для избежания LazyInitializationException, учитывая аспекты производительности?](#47-какие-есть-способы-оптимизации-работы-с-данными-для-избежания-lazyinitializationexception-учитывая-аспекты-производительности)

[48. Что такое проблема N+1 в контексте JPA / Hibernate?](#48-что-такое-проблема-n1-в-контексте-jpa--hibernate)

[49. Какие существуют базовые подходы к решению проблемы N+1 в JPA / Hibernate?](#49-какие-существуют-базовые-подходы-к-решению-проблемы-n1-в-jpa--hibernate)

[50. Может ли использование ленивой загрузки (lazy loading) привести к проблеме N+1? Если да, то как?](#50-может-ли-использование-ленивой-загрузки-lazy-loading-привести-к-проблеме-n1-если-да-то-как)

[51. Как использование JPQL/HQL запросов может помочь в решении проблемы N+1?](#51-как-использование-jpqlhql-запросов-может-помочь-в-решении-проблемы-n1)

[52. Какие аннотации в JPA могут быть использованы для оптимизации и предотвращения проблемы N+1?](#52-какие-аннотации-в-jpa-могут-быть-использованы-для-оптимизации-и-предотвращения-проблемы-n1)

[53. Как роль графа сущностей (entity graph) связана с решением проблемы N+1?](#53-как-роль-графа-сущностей-entity-graph-связана-с-решением-проблемы-n1)

[54. Как можно решить проблему N+1 при использовании Criteria API?](#54-как-можно-решить-проблему-n1-при-использовании-criteria-api)

[55. Какие есть подходы к программному управлению инициализацией связанных сущностей для избежания проблемы N+1?](#55-какие-есть-подходы-к-программному-управлению-инициализацией-связанных-сущностей-для-избежания-проблемы-n1)

[56. Как использование проекций (DTO) может способствовать решению проблемы N+1?](#56-как-использование-проекций-dto-может-способствовать-решению-проблемы-n1)

[57. Что такое JPA?](#57-что-такое-jpa)

[58. Назовите хотя бы одну альтернативу Hibernate.](#58-назовите-хотя-бы-одну-альтернативу-hibernate)

[59. В чем состоит основное предназначение JPA?](#59-в-чем-состоит-основное-предназначение-jpa)

[60. Какие преимущества предоставляет использование JPA по сравнению с JDBC?](#60-какие-преимущества-предоставляет-использование-jpa-по-сравнению-с-jdbc)

[61. Перечислите хотя бы две альтернативы Hibernate и укажите их ключевые особенности.](#61-перечислите-хотя-бы-две-альтернативы-hibernate-и-укажите-их-ключевые-особенности)

[62. Какие стратегии наследования поддерживает JPA?](#62-какие-стратегии-наследования-поддерживает-jpa)

[63. Опишите процесс интеграции JPA с Spring Framework.](#63-опишите-процесс-интеграции-jpa-с-spring-framework)

[64. Какие есть подходы к оптимизации производительности при использовании JPA?](#64-какие-есть-подходы-к-оптимизации-производительности-при-использовании-jpa)

[65. Как реализовать многотенантность в приложении, используя JPA?](#65-как-реализовать-многотенантность-в-приложении-используя-jpa)

# 1. Что такое JPA и для чего она используется?

JPA (Java Persistence API) — это стандарт для работы с реляционными базами данных в Java-приложениях, который позволяет
использовать объектно-реляционное отображение (ORM). JPA упрощает взаимодействие между объектами Java и базой данных,
избавляя разработчиков от необходимости писать SQL-запросы для основных операций с данными. Она поддерживает
автоматическое преобразование объектов в таблицы и наоборот, управление транзакциями, кэширование и обеспечивает
портируемость между различными СУБД. JPA активно используется в таких фреймворках, как Hibernate

[К оглавлению](#JpaHibernate)

# 2. Какие основные преимущества использования JPA по сравнению с JDBC?

JPA (Java Persistence API) предоставляет более высокий уровень абстракции для работы с базами данных по сравнению с
JDBC. Вместо того, чтобы вручную писать SQL-запросы для каждого действия, JPA позволяет работать с объектами, что
упрощает код и повышает его читабельность. JPA автоматически управляет транзакциями и поддерживает кэширование, что
улучшает производительность. Также, в отличие от JDBC, JPA предоставляет более гибкие средства для написания запросов,
такие как JPQL и Criteria API, что позволяет создавать сложные запросы на уровне объектов, не прибегая к написанию SQL.

[К оглавлению](#JpaHibernate)

# 3. Как определить сущность в JPA?

Чтобы определить сущность в JPA, класс необходимо аннотировать @Entity. Каждая сущность должна иметь поле с уникальным
идентификатором, помеченным @Id. Обычно для генерации ключа используется аннотация @GeneratedValue. Опционально можно
указать имя таблицы через @Table. Все поля, которые должны храниться в базе, описываются как обычные поля класса с
геттерами и сеттерами.

[К оглавлению](#JpaHibernate)

# 4. Какие стратегии наследования поддерживает JPA?

В JPA поддерживаются три стратегии наследования: SINGLE_TABLE, JOINED и TABLE_PER_CLASS. В стратегии SINGLE_TABLE все
сущности сохраняются в одной таблице с дополнительным столбцом для определения типа сущности. В стратегии JOINED для
каждого класса создается отдельная таблица, и данные объединяются через JOIN. В стратегии TABLE_PER_CLASS каждая
сущность имеет свою собственную таблицу, которая включает все поля, включая родительские. Выбор стратегии зависит от
требований к нормализации данных и производительности.

[К оглавлению](#JpaHibernate)

# 5. Как реализовать отношения один-ко-многим в JPA?

В JPA отношение один-ко-многим реализуется с помощью аннотации @OneToMany на стороне "один" и @ManyToOne на стороне "
многие". При этом в базе данных создаётся внешний ключ в таблице "многие", ссылающийся на таблицу "один". Для
bidirectional-связи используется параметр mappedBy, чтобы избежать создания лишней промежуточной таблицы. Также можно
использовать cascade и orphanRemoval, чтобы управлять жизненным циклом дочерних сущностей через родительскую.

[К оглавлению](#JpaHibernate)

# 6. Как работает кэширование в JPA и какие типы кэшей поддерживаются?

JPA поддерживает двухуровневое кэширование.

`Кэш первого уровня (First Level Cache)` - всегда включен.

Что это:
Встроенный механизм кэширования в рамках EntityManager.

Как работает:
Когда вы загружаете сущность через find() или getReference(), она сохраняется в кэше внутри EntityManager. Повторные
обращения к этой же сущности в пределах одного EntityManager не выполняют повторный SQL-запрос, а возвращают данные из
кэша.

Область действия:
Только текущий EntityManager. После закрытия — кэш удаляется.

`Кэш второго уровня (Second Level Cache)` — опциональный, настраивается вручную

Что это:
Это глобальный кэш для всех EntityManager, работающий на уровне EntityManagerFactory.

Зачем нужен:
Чтобы уменьшить количество запросов к базе данных при повторном использовании данных между сессиями или при
масштабировании.

Область действия:
В пределах всего приложения (или нескольких инстансов, если настроено кластерное кэширование).

Требует конфигурации и провайдера, например: Ehcache Infinispan Hazelcast Redis (интеграция через сторонние библиотеки)

Как включить кэш второго уровня: Добавить зависимость в pom, настроить application.properties, включить кэширование на
сущности

```java
<dependency>
    <groupId>org.hibernate.orm</groupId>
    <artifactId>hibernate-ehcache</artifactId>
    <version>...</version>
</dependency>


spring.jpa.properties.hibernate.cache.use_second_level_cache=true
spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.jcache.JCacheRegionFactory


@Entity
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class User {
    @Id
    private Long id;
    private String name;
}
```

[К оглавлению](#JpaHibernate)

# 7. Как можно интегрировать пользовательские SQL запросы в JPA?

В JPA можно использовать пользовательские SQL-запросы через JPQL или через нативный SQL. JPQL подходит для типичных
операций с сущностями, а нативные SQL-запросы используются, когда нужны функции СУБД или нестандартные объединения. В
Spring Data JPA я часто использую аннотацию @Query с nativeQuery = true, или создаю кастомные репозитории с
EntityManager. Также можно использовать @NamedNativeQuery для вынесения SQL-запросов в аннотации. Это даёт большую
гибкость при работе с базой данных.

[К оглавлению](#JpaHibernate)

# 8. Какие подходы к оптимистичной и пессимистичной блокировке поддерживаются в JPA?

В JPA поддерживаются два подхода к блокировке: оптимистичный и пессимистичный. Оптимистичная блокировка реализуется
через аннотацию @Version и предполагает разрешение конфликтов при сохранении. Это эффективно при низкой конкуренции.
Пессимистичная блокировка накладывает реальные блокировки в базе данных через LockModeType.PESSIMISTIC_`*` и используется,
когда конфликты высоковероятны.

`*` - Типы блокировок:

READ	LockModeType.PESSIMISTIC_READ	Блокирует от изменений другими

WRITE	LockModeType.PESSIMISTIC_WRITE	Блокирует от чтения и записи

FORCE_INCREMENT	LockModeType.OPTIMISTIC_FORCE_INCREMENT	Обновляет версию при чтении

[К оглавлению](#JpaHibernate)

# 9. Как реализовать мульти-тенантность в приложении с использованием JPA?

Мульти-тенантность в JPA позволяет работать с несколькими тенантами (клиентами) в одном приложении, обеспечивая при этом
изоляцию данных каждого тенанта.

- На уровне схемы — каждый тенант работает в своей схеме в одной базе данных. Это помогает изолировать данные, но
  накладывает дополнительные требования на управление схемами.

- На уровне таблиц — все данные хранятся в одной таблице, но каждый запрос фильтруется по tenant_id. Это упрощает
  управление, но может потребовать дополнительной работы для правильной изоляции данных.

- На уровне соединений — каждому тенанту выделяется своё подключение к базе данных. Это обеспечивает полную изоляцию
  данных, но требует управления множеством подключений.
  Для реализации мульти-тенантности можно использовать аннотации JPA, например, @TenantId и @Query, а также настройки
  Hibernate для работы с различными схемами или подключениями.

[К оглавлению](#JpaHibernate)

# 10. Расскажите что такое FetchType?

FetchType в JPA определяет стратегию загрузки связанных сущностей. EAGER (жадная загрузка) загружает все связанные данные сразу, что может привести к лишним запросам и большому потреблению памяти. LAZY (ленивая загрузка) загружает данные только по требованию, что эффективно с точки зрения производительности, но требует аккуратности в управлении сессиями, чтобы избежать ошибок типа LazyInitializationException. Я обычно использую LAZY по умолчанию, а EAGER только там, где это действительно необходимо для производительности приложения.

[К оглавлению](#JpaHibernate)

# 11. Опишите, какие состояния Entity существуют в Hibernate?

Transient: Объект только что создан и не привязан к сессии. Он не существует в базе данных.

Persistent: Объект сохранён в базе данных и связан с сессией. Изменения этого объекта будут автоматически синхронизированы с базой данных.

Detached: Объект был отсоединён от сессии, и теперь Hibernate не отслеживает его изменения. Чтобы снова синхронизировать объект с базой данных, нужно использовать методы merge() или update().

Removed: Объект помечен для удаления и будет удалён из базы данных при следующем flush или commit транзакции.

[К оглавлению](#JpaHibernate)

# 12. Что такое Hibernate и какие основные преимущества он предлагает?

Hibernate — это фреймворк для объектно-реляционного отображения (ORM), который позволяет работать с базой данных через объекты Java. Основные преимущества Hibernate включают автоматическое преобразование объектов в записи таблиц, поддержку различных СУБД, управление транзакциями и сессиями, а также механизмы кэширования для улучшения производительности. Hibernate позволяет работать с ленивой и жадной загрузкой данных, поддерживает HQL (объектно-ориентированный язык запросов) и обеспечивает поддержку различных типов связей между сущностями. Это значительно упрощает работу с реляционными базами данных и повышает производительность приложения за счет оптимизации запросов и кэширования.

[К оглавлению](#JpaHibernate)

# 13. Опишите, какой FetchType по умолчанию при каждой связи между двумя сущностями?

@OneToMany — LAZY. Это позволяет загружать связанные сущности по мере необходимости, что улучшает производительность при работе с большими коллекциями.

@ManyToOne — EAGER. Это значит, что связанная сущность будет загружена сразу, что удобно, когда эта связь всегда используется и необходима.

@OneToOne — EAGER. Связь один к одному также загружается сразу, что оправдано в случаях, когда сущности часто используются вместе.

@ManyToMany — LAZY. Это позволяет загружать коллекции связанных сущностей только по запросу, предотвращая избыточные данные.

[К оглавлению](#JpaHibernate)

# 14. Расскажите что такое каскадирование и как каскадные операции влияют на управление данными в БД?

Каскадирование операций в JPA — это механизм, позволяющий автоматически выполнять операции с сущностями, связанными с текущей сущностью, при выполнении этих операций над самой сущностью. С помощью аннотации @Cascade можно настроить, какие операции (сохранение, обновление, удаление и т.д.) должны каскадировать на связанные сущности. Например, если я сохраняю сущность Order, то все связанные с ней OrderItem автоматически сохраняются в базе данных. Это значительно упрощает работу с данными, гарантирует консистентность и уменьшает ошибки, но также требует осторожности, чтобы не привести к неожиданным потерям данных или избыточной нагрузке на систему.

[К оглавлению](#JpaHibernate)

# 15. Что такое встраиваемый (Embeddable) класс?

@Embeddable класс в JPA — это способ скомпоновать несколько полей в один логический объект, который затем встраивается (@Embedded) в сущность (@Entity). Такие классы не имеют собственной таблицы в БД — их поля сохраняются в таблице родительской сущности. Это удобно для группировки часто используемых данных (например, адресов, координат, денежных сумм с валютой) без создания лишних связей

[К оглавлению](#JpaHibernate)

# 16. Какие стратегии наследования имеются в Hibernate?

В Hibernate есть 4 основные стратегии наследования:

SINGLE_TABLE — все классы иерархии хранятся в одной таблице с дискриминатором. Быстро, но возможны NULL-поля.

JOINED — каждому классу своя таблица, связь через JOIN’ы. Нормализованная структура, но менее производительно.

TABLE_PER_CLASS — таблица для каждого конкретного класса (включая абстрактные). Избегает JOIN’ов, но приводит к дублированию.

@MappedSuperclass — родительский класс не является сущностью, его поля «встраиваются» в наследников.

Выбор зависит от требований: если важна скорость — SINGLE_TABLE, если чистота БД — JOINED

[К оглавлению](#JpaHibernate)

# 17. Для чего нужны callback методы в Hibernate? К каким сущностям применяются аннотации callback методов?

Callback-методы в Hibernate позволяют выполнять произвольную логику на ключевых этапах жизненного цикла сущности. Они применяются через аннотации:

@PrePersist / @PostPersist — до/после сохранения.

@PreUpdate / @PostUpdate — до/после обновления.

@PreRemove / @PostRemove — до/после удаления.

@PostLoad — после загрузки из БД.

Их можно добавлять в методы @Entity, @Embeddable или @MappedSuperclass-классов. Типичные use-cases: валидация, логирование, обновление производных полей (например, lastModifiedDate).

*Важно: методы должны быть void и без параметров, либо принимать только EntityManager (в JPA 2.2+)

[К оглавлению](#JpaHibernate)

# 18. Расскажите, что такое EntityGraph?

EntityGraph в JPA — это механизм для управления жадной (EAGER) загрузкой связанных сущностей на уровне конкретного запроса (а не глобально через FetchType). Он позволяет:

Избежать N+1 проблемы (когда ленивые связи грузятся отдельными запросами).

Гибко настраивать загружаемые ассоциации (например, для разных API — разные наборы данных).

Используется через:

@NamedEntityGraph (статическое объявление в @Entity),

Динамическое создание (em.createEntityGraph()).

Важно: EntityGraph переопределяет FetchType (даже LAZY связи грузятся, если указаны в графе).

[К оглавлению](#JpaHibernate)

# 19. Какие виды кэша есть в Hibernate и какими способами.

В Hibernate есть 3 типа кэширования:

Кэш первого уровня (L1) — привязан к сессии, работает "из коробки", очищается после закрытия сессии.

Кэш второго уровня (L2) — общий для всех сессий, требует настройки (Ehcache, Infinispan) и аннотации @Cacheable.

Кэш запросов — кеширует результаты HQL/JPA-запросов, работает только с включённым L2.

*Стратегии L2-кеша (READ_ONLY, READ_WRITE и др.) зависят от частоты обновления данных. Query Cache требует осторожности — он инвалидируется при изменениях

[К оглавлению](#JpaHibernate)

# 20. Какие варианты настройки есть для второго уровеня кэша?

Настройка L2-кеша в Hibernate включает:

Выбор провайдера (Ehcache, Infinispan, Hazelcast и др.) через hibernate.cache.region.factory_class.

Включение кэша (hibernate.cache.use_second_level_cache=true).

Разметка сущностей аннотациями:

@Cacheable — разрешает кэширование.

@Cache(usage = стратегия) — выбирает стратегию (READ_ONLY, READ_WRITE и др.).

Конфигурация регионов (например, в ehcache.xml) с настройкой TTL и размера.

Дополнительно можно:

Очищать кэш программно (sessionFactory.getCache().evictEntityRegion()).

Использовать @Cacheable для коллекций (@OneToMany).

Важно: стратегия READ_ONLY даёт максимум производительности, но не подходит для изменяемых данных

[К оглавлению](#JpaHibernate)

# 21. Что такое стратегия наследования в контексте JPA / Hibernate?

В JPA/Hibernate есть 3 основные стратегии наследования:*

SINGLE_TABLE — все классы хранятся в одной таблице с дискриминатором. Быстро, но возможны NULL-значения.

JOINED — отдельная таблица для каждого класса + JOIN’ы. Нормализованная структура, но менее производительно.

TABLE_PER_CLASS — таблица для каждого конкретного класса (с дублированием полей). Избегает JOIN’ов, но использует UNION ALL.

Дополнительно:

@MappedSuperclass — родительский класс не является сущностью, его поля "встраиваются" в наследников.

Выбор зависит от требований:

Если нужна скорость → SINGLE_TABLE.

Если важна нормализация БД → JOINED.

Если много разных полей у наследников → TABLE_PER_CLASS.

[К оглавлению](#JpaHibernate)

# 22. Каковы основные стратегии наследования, поддерживаемые JPA?

JPA поддерживает три стратегии наследования:

SINGLE_TABLE — все классы хранятся в одной таблице с дискриминатором. Быстро, но приводит к NULL-полям.

JOINED — отдельная таблица для каждого класса + JOIN’ы. Нормализованная структура, но менее производительно.

TABLE_PER_CLASS — таблица для каждого конкретного класса (с дублированием полей). Избегает JOIN’ов, но использует UNION ALL.

Дополнительно @MappedSuperclass позволяет выносить общие поля без создания сущности. Выбор зависит от требований к производительности и структуре БД.

[К оглавлению](#JpaHibernate)

# 23. Как указать стратегию наследования в JPA с помощью аннотаций?

В JPA стратегия наследования задаётся аннотацией @Inheritance на родительском классе. Доступны 3 варианта:

SINGLE_TABLE — все подклассы в одной таблице с дискриминатором (@DiscriminatorColumn).

JOINED — отдельные таблицы для каждого класса + JOIN по id.

TABLE_PER_CLASS — таблица для каждого конкретного класса (с дублированием полей).

Дополнительно @MappedSuperclass позволяет выносить общие поля без создания сущности. Выбор зависит от требований к производительности и структуре БД

[К оглавлению](#JpaHibernate)

# 24. Какие преимущества и недостатки имеет стратегия SINGLE_TABLE при использовании в JPA / Hibernate?

Стратегия SINGLE_TABLE в JPA хранит всю иерархию классов в одной таблице, используя дискриминатор (@DiscriminatorColumn). Её плюсы:

Высокая производительность (нет JOIN’ов).

Простота запросов (все данные в одном месте).

Но есть минусы:

NULL-значения для полей, специфичных подклассам.

Нарушает нормализацию (избыточность данных).

Ограничения на NOT NULL для полей подклассов.

Используйте её, когда важна скорость, а количество подклассов и их полей невелико.»

Дополнительно:

Как избежать NULL?

Использовать JOINED, если NULL мешает.

Можно ли добавить индекс на дискриминатор?

Да, это ускорит фильтрацию по типу.

[К оглавлению](#JpaHibernate)

# 25. Как работает стратегия JOINED в контексте наследования сущностей в JPA / Hibernate?

JOINED — стратегия JPA, где каждый класс в иерархии наследования имеет свою таблицу. Общие поля хранятся в родительской таблице, а уникальные — в дочерних, с связью по id.

Плюсы:

Нормализованная БД (нет NULL, дублирования).

Гибкие constraints.

Минусы:

Требует JOIN’ов (может быть медленнее SINGLE_TABLE).

Используйте её, когда важна чистота схемы БД, а не максимальная скорость.»*

Дополнительно:

Как оптимизировать JOIN’ы?

Использовать @Fetch(FetchMode.JOIN) для жадной загрузки.

Чем отличается от TABLE_PER_CLASS?

В JOINED родитель — отдельная таблица, а в TABLE_PER_CLASS — нет.

[К оглавлению](#JpaHibernate)

# 26. В чем различие между стратегиями TABLE_PER_CLASS и SINGLE_TABLE в JPA?

"В JPA стратегия SINGLE_TABLE подразумевает хранение всей иерархии в одной таблице с дополнительной колонкой для определения типа. Это удобно для выборки всех сущностей, но может привести к множеству NULL-полей.

Стратегия TABLE_PER_CLASS создает отдельную таблицу для каждого класса, включая унаследованные поля. Такой подход чище и нормализованнее, но сложнее при работе с общей выборкой по иерархии.

Выбор зависит от баланса между производительностью запросов и нормализацией данных.

[К оглавлению](#JpaHibernate)

# 27. Какие особенности реализации стратегии наследования TABLE_PER_CLASS в Hibernate по сравнению с другими стратегиями?

В Hibernate при использовании стратегии TABLE_PER_CLASS каждая сущность в иерархии сохраняется в отдельной таблице, включая родительский класс. Все поля, даже унаследованные, дублируются в каждой таблице. Это позволяет избежать NULL-значений и обеспечивает нормализованную структуру данных. Однако, полиморфные запросы выполняются через UNION, что может привести к снижению производительности. Также важно отметить, что использование GenerationType.IDENTITY может привести к пересечению идентификаторов между потомками

[К оглавлению](#JpaHibernate)

# 28. Как стратегия наследования влияет на производительность запросов в JPA / Hibernate?

Стратегии наследования в JPA оказывают существенное влияние на производительность.

SINGLE_TABLE обеспечивает максимальную скорость при полиморфных запросах, но за счёт большого количества NULL-значений.

TABLE_PER_CLASS предлагает чистую структуру БД, но полиморфные запросы выполняются через UNION, что может быть медленно.

JOINED даёт нормализованную модель, но требует множества JOIN'ов, что тоже влияет на производительность.

Выбор стратегии зависит от баланса между скоростью выполнения запросов и структурой данных

[К оглавлению](#JpaHibernate)

# 29. Как реализовать кастомную стратегию наследования в JPA / Hibernate, не предусмотренную стандартом?

JPA предоставляет три встроенные стратегии наследования, но если их недостаточно, в Hibernate можно реализовать кастомную логику.

Например, можно использовать @Where или @Any для гибкой фильтрации и определения типа.

Для более сложных случаев — можно написать собственный EntityPersister, чтобы полностью контролировать, как сущности сохраняются и загружаются.

Также можно обойтись DTO и маппингом на уровне бизнес-логики, если требуется максимальная гибкость.

[К оглавлению](#JpaHibernate)

# 30. Что такое стратегия генерации ID в контексте JPA?

Стратегия генерации ID в JPA определяет, как будет задаваться уникальный идентификатор сущности.

- IDENTITY — когда БД сама назначает ID через автоинкремент. 
- SEQUENCE — использует sequence из БД, удобно для batch-вставок. 
- TABLE — эмуляция sequence через таблицу, совместима почти со всем.
- AUTO — Hibernate сам выбирает подходящую стратегию.
- Выбор зависит от используемой СУБД и требований к производительности.

[К оглавлению](#JpaHibernate)

# 31. Какие вы знаете стратегии генерации ID, предоставляемые JPA?

PA предоставляет четыре стратегии генерации ID:

AUTO — когда Hibernate сам выбирает подходящую стратегию.
IDENTITY — когда ID назначается БД через автоинкремент.
SEQUENCE — используется sequence из БД, хорошо подходит для batch-операций.
TABLE — эмуляция sequence через таблицу, совместима почти со всем.
Выбор зависит от СУБД и требований к производительности.

[К оглавлению](#JpaHibernate)

# 32. Для чего используется аннотация @GeneratedValue в JPA?

Аннотация @GeneratedValue в JPA используется для автоматической генерации уникальных значений поля @Id. Она позволяет указать, каким образом будет формироваться идентификатор: через автоинкремент (IDENTITY), последовательность (SEQUENCE), таблицу (TABLE) или автоматически (AUTO).

Также можно задавать кастомные генераторы с помощью @SequenceGenerator или @TableGenerator, если нужна дополнительная настройка.

[К оглавлению](#JpaHibernate)

# 33. Как работает стратегия AUTO для генерации ID в JPA?

Стратегия AUTO в JPA позволяет Hibernate автоматически выбрать наиболее подходящий способ генерации ID, исходя из возможностей текущей СУБД. Например, в PostgreSQL это будет SEQUENCE, а в MySQL — TABLE. Это удобно, когда нужно сохранить кроссплатформенность и не привязываться к конкретной реализации БД. Однако, если важен полный контроль над процессом, лучше явно указать нужную стратегию.

[К оглавлению](#JpaHibernate)

# 34. В чем разница между стратегиями SEQUENCE и TABLE для генерации ID в JPA?

Стратегия SEQUENCE использует sequence из базы данных для генерации ID. Она быстрая и хорошо работает с batch-вставками, но зависит от поддержки СУБД.

Стратегия TABLE эмулирует sequence через обычную таблицу, что делает её более универсальной, но медленной и требовательной к блокировкам.

Выбор зависит от используемой СУБД и требований к производительности

[К оглавлению](#JpaHibernate)

# 35. Как настроить кастомный генератор ID в JPA, используя @GenericGenerator?

В Hibernate можно настроить кастомный генератор ID с помощью аннотации @GenericGenerator. Она позволяет либо использовать встроенные стратегии (uuid, assigned и др.), либо написать собственную реализацию через класс, реализующий IdentifierGenerator.

Это особенно полезно, когда требуется бизнес-специфичная логика формирования ID, например, читаемые номера с префиксами, датами или другими метками.

[К оглавлению](#JpaHibernate)

# 36. Какие преимущества и недостатки у стратегии IDENTITY с точки зрения производительности в JPA?

Стратегия IDENTITY позволяет БД самой генерировать ID через автоинкремент. Это просто и удобно, особенно для небольших проектов. Однако с точки зрения производительности у неё есть серьёзный недостаток: Hibernate не может заранее знать ID, из-за чего невозможно использовать эффективную пакетную вставку (batch insert). Поэтому эту стратегию лучше выбирать, если производительность не критична, а простота реализации важнее.

[К оглавлению](#JpaHibernate)

# 37. Как стратегия SEQUENCE генерации ID влияет на возможность оптимистичной блокировки в JPA?

Стратегия SEQUENCE не влияет напрямую на работу оптимистичной блокировки через @Version. Оба механизма решают разные задачи: @Version контролирует целостность данных при параллельных изменениях, а SEQUENCE — генерацию уникальных ID. Однако SEQUENCE косвенно помогает производительности, особенно при массовой вставке, благодаря возможности заранее выделять блоки ID.

[К оглавлению](#JpaHibernate)

# 38. В каких случаях предпочтительно использовать стратегию TABLE для генерации ID и почему?

Стратегия TABLE используется, когда нужно обеспечить максимальную совместимость между СУБД, особенно если база данных не поддерживает sequence. Она позволяет эмулировать генерацию ID через обычную таблицу, где Hibernate сам управляет значениями. Эта стратегия удобна для проектов с мульти-БД или legacy-систем, но имеет ограничения по производительности из-за частых обращений к таблице.

[К оглавлению](#JpaHibernate)

# 39. Что такое LazyInitializationException в контексте JPA / Hibernate?

LazyInitializationException возникает в Hibernate, когда мы пытаемся получить доступ к лениво загруженной сущности вне активной сессии. Это происходит, потому что Hibernate не может выполнить дополнительный запрос к базе данных, если соединение уже закрыто. Чтобы избежать этой ошибки, можно использовать аннотацию @Transactional, принудительную инициализацию через Hibernate.initialize(), или загружать связанные данные сразу с помощью JOIN FETCH в JPQL

[К оглавлению](#JpaHibernate)

# 40. Какие основные причины возникновения LazyInitializationException?

Основные причины LazyInitializationException:

- Доступ к lazy-связям вне активной сессии. 
- Отсутствие @Transactional при работе с сущностями. 
- Неявное использование lazy-полей в DTO или при сериализации в JSON. 
- Сериализация через Jackson без специальной настройки. 
- Неправильное обращение к proxy-объектам. 
- Чтобы избежать ошибки, можно использовать @Transactional, JOIN FETCH, явную инициализацию через Hibernate.initialize() или работать с DTO вместо сущностей.

[К оглавлению](#JpaHibernate)

# 41. Какие есть способы предотвращения LazyInitializationException без изменения стратегии загрузки?

Чтобы  избежать LazyInitializationException, не меняя стратегию загрузки (LAZY), можно использовать следующие подходы:

- Аннотацию @Transactional, чтобы держать сессию открытой. 
- Принудительную инициализацию через Hibernate.initialize(). 
- Запросы с JOIN FETCH для одновременной загрузки связей. 
- Использование EntityGraph для динамического указания, какие поля загружать. 
- Маппинг в DTO внутри транзакции. 
- Настройку Hibernate5Module в Jackson для корректной сериализации. 
- Лучшие практики — использовать JOIN FETCH или DTO внутри транзакции

[К оглавлению](#JpaHibernate)

# 42. Как работает ленивая загрузка (lazy loading) в Hibernate и когда она может привести к LazyInitializationException?

Ленивая загрузка (lazy loading) в Hibernate позволяет откладывать загрузку связанных данных до тех пор, пока они действительно не понадобятся. Это реализуется через proxy-объекты, которые делают запрос к БД только при первом обращении к данным. Однако, если попытаться получить доступ к таким данным вне активной сессии или транзакции, будет выброшено исключение LazyInitializationException. Чтобы этого избежать, можно использовать @Transactional, JOIN FETCH, DTO или настройки сериализации через Hibernate5Module.

[К оглавлению](#JpaHibernate)

# 43. Какие есть способы обработки LazyInitializationException в Spring-приложении?

В Spring-приложениях LazyInitializationException можно обработать или предотвратить несколькими способами:

- Использовать @Transactional, чтобы держать сессию открытой до конца метода. 
- Загружать связи сразу через JOIN FETCH. 
- Принудительно инициализировать коллекции через Hibernate.initialize(). 
- Использовать DTO и мапперы внутри транзакции. 
- Настроить Hibernate5Module для корректной сериализации lazy-полей. 
- Использовать EntityGraph для динамической загрузки связей. 
- Лучшие практики — использовать JOIN FETCH или DTO внутри транзакции. Глобальная настройка spring.jpa.open-in-view=true работает, но считается плохой практикой

[К оглавлению](#JpaHibernate)

# 44. Как можно использовать Hibernate.initialize() для решения проблемы LazyInitializationException?

Hibernate.initialize() используется для принудительной загрузки lazy-связей внутри активной транзакции. Это позволяет избежать LazyInitializationException, даже если позже обращение к этим данным будет происходить вне сессии. Этот метод особенно удобен при использовании DTO или сериализации в JSON, когда важно заранее убедиться, что все нужные данные загружены.

[К оглавлению](#JpaHibernate)

# 45. Как можно использовать паттерн Open Session In View для решения проблемы LazyInitializationException, и какие у этого подхода могут быть недостатки?

Паттерн Open Session In View позволяет избежать LazyInitializationException, держа Hibernate-сессию открытой до конца HTTP-запроса. Он удобен для небольших проектов и упрощает работу с lazy-связями в контроллерах. Однако, у него есть серьёзные недостатки: скрытие N+1 проблем, долгие транзакции и нарушение разделения слоёв. Поэтому его лучше использовать осознанно и только если вы понимаете риски.

[К оглавлению](#JpaHibernate)
 
# 46. В каких случаях использование @Transactional может помочь в решении проблемы LazyInitializationException и как правильно его применять?

@Transactional помогает избежать LazyInitializationException, потому что держит Hibernate-сессию открытой до конца метода. Это позволяет безопасно обращаться к lazy-связям внутри метода. Чтобы использовать её правильно, нужно ставить её на public-методы сервисов, избегать self-invocation и не использовать в контроллерах. Также можно настраивать поведение транзакции: сделать её read-only, указать, какие исключения должны вызывать откат

[К оглавлению](#JpaHibernate)

# 47. Какие есть способы оптимизации работы с данными для избежания LazyInitializationException, учитывая аспекты производительности?

Чтобы избежать LazyInitializationException с учётом производительности, я использую следующие подходы:

- JOIN FETCH для загрузки связей в одном запросе. 
- DTO и projections, чтобы загружать только нужные данные. 
- @BatchSize для уменьшения количества N+1 запросов. 
- Hibernate.initialize() внутри транзакции. 
- EntityGraph для динамического управления фетчингом. 
- Также я стараюсь не использовать EAGER и spring.jpa.open-in-view=true, чтобы не скрывать проблемы производительности

[К оглавлению](#JpaHibernate)

# 48. Что такое проблема N+1 в контексте JPA / Hibernate?

Проблема N+1 в JPA возникает, когда Hibernate делает отдельный SQL-запрос для каждой ленивой связи в списке сущностей. Это приводит к значительному снижению производительности. Чтобы избежать этого, можно использовать JOIN FETCH, DTO-проеции, @BatchSize или EntityGraph. Лучше всего использовать JOIN FETCH или DTO, чтобы загрузить все данные за один или несколько оптимизированных запросов.

[К оглавлению](#JpaHibernate)

# 49. Какие существуют базовые подходы к решению проблемы N+1 в JPA / Hibernate?


Чтобы решить проблему N+1 в JPA / Hibernate, я использую следующие подходы:

- JOIN FETCH для загрузки связей в одном запросе. 
- DTO и projections, чтобы загружать только нужные данные. 
- @BatchSize для уменьшения количества N+1 запросов. 
- Hibernate.initialize() внутри транзакции. 
- EntityGraph для динамического управления фетчингом. 
- Эти методы позволяют значительно повысить производительность и избежать лишних обращений к базе данных

[К оглавлению](#JpaHibernate)

# 50. Может ли использование ленивой загрузки (lazy loading) привести к проблеме N+1? Если да, то как?

Да, использование ленивой загрузки (fetch = FetchType.LAZY) может привести к проблеме N+1, особенно если ты обращаешься к lazy-связям в цикле или через мапперы. Это происходит потому, что Hibernate делает отдельный SQL-запрос для каждой сущности. Чтобы избежать этой проблемы, можно использовать JOIN FETCH, DTO-проекции, @BatchSize или EntityGraph. Лучше всего загружать нужные связи заранее в одном эффективном запросе.

[К оглавлению](#JpaHibernate)

# 51. Как использование JPQL/HQL запросов может помочь в решении проблемы N+1?

Использование JPQL или HQL с JOIN FETCH позволяет решить проблему N+1, загружая основную сущность и её связи в одном запросе. Это значительно повышает производительность, особенно при работе с большими списками. Также можно использовать DTO-проекции, чтобы загружать только нужные данные и избежать ленивой инициализации

[К оглавлению](#JpaHibernate)

# 52. Какие аннотации в JPA могут быть использованы для оптимизации и предотвращения проблемы N+1?

Чтобы предотвратить проблему N+1 в JPA, я использую следующие аннотации:

- @BatchSize — чтобы загружать связи группами, а не по одной. 
- @Fetch(FetchMode.SUBSELECT) — для загрузки всех связей одним запросом. 
- @EntityGraph или @NamedEntityGraph — для динамического управления фетчингом. 
- JOIN FETCH в JPQL — чтобы загружать всё сразу в одном запросе. 
- DTO-проекции — чтобы загружать только нужные данные. 
- Эти подходы значительно повышают производительность и избегают лишних обращений к базе данных.

[К оглавлению](#JpaHibernate)

# 53. Как роль графа сущностей (entity graph) связана с решением проблемы N+1?

Entity Graph в JPA позволяет динамически указывать, какие связи нужно загружать при выборке сущности. Это помогает избежать проблемы N+1, потому что все указанные связи загружаются сразу в одном SQL-запросе через JOIN FETCH. Это особенно полезно, когда нужно гибко управлять фетчингом без изменения JPQL-запросов или создания множества методов в репозитории

[К оглавлению](#JpaHibernate)

# 54. Как можно решить проблему N+1 при использовании Criteria API?

Проблему N+1 можно решить через Criteria API, используя метод fetch() для явной загрузки связанных данных. Это позволяет загрузить основную сущность и её связи в одном SQL-запросе, аналогично JOIN FETCH в JPQL. Это особенно полезно, когда требуется гибкая и динамическая загрузка данных без множества лишних обращений к базе.

[К оглавлению](#JpaHibernate)
 
# 55. Какие есть подходы к программному управлению инициализацией связанных сущностей для избежания проблемы N+1?

Чтобы программно управлять инициализацией связанных сущностей и избежать N+1, я использую следующие подходы:

- JOIN FETCH в JPQL или HQL — загрузка связей в одном запросе. 
- Criteria API с методом fetch() — гибкая и типобезопасная загрузка. 
- Hibernate.initialize() внутри транзакции — принудительная инициализация. 
- DTO и projections — загрузка только нужных данных. 
- @BatchSize — уменьшение количества N+1 запросов. 
- EntityGraph — динамическое управление фетчингом. 
- Эти подходы позволяют мне эффективно работать с данными и избегать лишних обращений к базе

[К оглавлению](#JpaHibernate)

# 56. Как использование проекций (DTO) может способствовать решению проблемы N+1?

DTO-проекции позволяют загружать только нужные данные в одном SQL-запросе, исключая необходимость дальнейших обращений к БД. Это особенно эффективно для решения проблемы N+1, потому что позволяет избежать работы с lazy-связями. Я использую как интерфейсные проекции, так и классовые DTO, в зависимости от задачи. Конструкторные DTO дают максимальный контроль, а interface-based projections — удобство.

[К оглавлению](#JpaHibernate)

# 57. Что такое JPA?

JPA (Java Persistence API) — это стандарт Java для работы с реляционными базами данных через объектно-ориентированный подход. Он предоставляет аннотации и API для маппинга Java-объектов на таблицы БД и управления их жизненным циклом.

Основные возможности: работа с сущностями, поддержка различных стратегий генерации ID, ленивая/жадная загрузка, JPQL-запросы.

JPA — это не реализация, а спецификация. Самая популярная реализация — Hibernate.

[К оглавлению](#JpaHibernate)

# 58. Назовите хотя бы одну альтернативу Hibernate.

Одной из популярных альтернатив Hibernate является EclipseLink — это тоже реализация спецификации JPA, но с расширенным функционалом, например, поддержкой Object-XML Mapping и Service Data Objects.

Также существуют не-JPA ORM, такие как MyBatis, jOOQ, Spring Data JDBC — они подходят, если нужно больше контроля над SQL или меньше абстракций.

[К оглавлению](#JpaHibernate)

# 59. В чем состоит основное предназначение JPA?

Основное предназначение JPA — обеспечить объектно-реляционное отображение (ORM) между Java-объектами и таблицами в реляционной БД.

Это даёт возможность разработчикам работать с базой данных на уровне объектов , без необходимости постоянно писать SQL-запросы.

JPA предоставляет API для управления жизненным циклом сущностей, поддерживает JPQL, ассоциации, транзакции и другие механизмы, которые делают работу с данными удобной и типобезопасной.

[К оглавлению](#JpaHibernate)

# 60. Какие преимущества предоставляет использование JPA по сравнению с JDBC?

JPA предоставляет высокоуровневую абстракцию над JDBC, позволяя работать с данными в ООП-стиле.

В отличие от JDBC, где разработчик сам управляет соединениями, пишет SQL и маппит результаты, JPA берёт эти задачи на себя: он автоматически маппит объекты, поддерживает транзакции, умеет работать с ассоциациями и поддерживает JPQL.

Это сильно упрощает разработку, особенно в больших проектах, и позволяет сосредоточиться на бизнес-логике, а не на технической части

[К оглавлению](#JpaHibernate)

# 61. Перечислите хотя бы две альтернативы Hibernate и укажите их ключевые особенности.

Две популярные альтернативы Hibernate — это EclipseLink и MyBatis .

- EclipseLink — это реализация JPA, как и Hibernate, но чаще используется в enterprise-средах и поддерживает дополнительные функции, такие как Object-XML Mapping.  
- MyBatis — это не классический ORM: он даёт полный контроль над SQL-запросами и подходит, когда нужно писать свои запросы, но при этом получать типобезопасные Java-объекты.

Выбор зависит от потребностей: если нужен стандартный ORM — выбираю Hibernate или EclipseLink, если нужен контроль над SQL — MyBatis.

[К оглавлению](#JpaHibernate)

# 62. Какие стратегии наследования поддерживает JPA?

JPA поддерживает три стратегии наследования:

- SINGLE_TABLE — вся иерархия в одной таблице с дискриминатором. Быстро работает с полиморфными запросами, но много NULL-полей. 
- JOINED — отдельные таблицы для каждого типа, связанные через JOIN. Чистый маппинг, но сложнее и медленнее. 
- TABLE_PER_CLASS — каждая сущность в своей таблице, включая унаследованные поля. Чисто, но плохо работает с полиморфными запросами.

Выбор зависит от баланса между производительностью, нормализацией данных и потребностями бизнес-логики

[К оглавлению](#JpaHibernate)

# 63. Опишите процесс интеграции JPA с Spring Framework.

Интеграция JPA с Spring позволяет использовать всю мощь ORM в экосистеме Spring.

- С помощью spring-boot-starter-data-jpa Spring автоматически настраивает DataSource, EntityManagerFactory, PlatformTransactionManager. 
- Можно использовать JpaRepository для CRUD-операций без реализации. 
- @Transactional управляет транзакциями, а @PersistenceContext предоставляет EntityManager. 
- Также поддерживаются маппинг сущностей, JPQL-запросы, ленивая загрузка и работа с транзакциями. 
- Это делает работу с базой данных удобной, типобезопасной и полностью интегрированной в Spring

[К оглавлению](#JpaHibernate)

# 64. Какие есть подходы к оптимизации производительности при использовании JPA?

Чтобы оптимизировать производительность при работе с JPA, я использую следующие подходы:

- JOIN FETCH в JPQL для загрузки связей одним запросом. 
- DTO и projections, чтобы загружать только нужные данные. 
- @BatchSize для уменьшения количества N+1 запросов. 
- Hibernate.initialize() внутри транзакции. 
- EntityGraph для динамического управления фетчингом. 
- Пакетную обработку и второй уровень кэша для повышения скорости. 
- Также я стараюсь не использовать spring.jpa.open-in-view=true, потому что это скрывает проблемы производительности (Эта настройка держит сессию открытой до конца HTTP-запроса → скрывает проблемы N+1. Лучше решать проблему корректно, чем маскировать её.)

[К оглавлению](#JpaHibernate)

# 65. Как реализовать многотенантность в приложении, используя JPA?

Многотенантность в JPA реализуется через механизмы Hibernate: CurrentTenantIdentifierResolver и MultiTenantConnectionProvider.

Я реализую schema-based многотенантность, где:

- Для каждого тенанта своя схема. 
- Текущий тенант определяется через ThreadLocal (например, из заголовка HTTP). 
- Hibernate автоматически переключается на нужную схему при работе с БД. 
- Это позволяет масштабировать SaaS-приложения, сохраняя чистую архитектуру и изоляцию данных

[К оглавлению](#JpaHibernate)